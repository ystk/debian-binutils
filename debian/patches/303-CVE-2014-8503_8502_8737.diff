#! /bin/sh /usr/share/dpatch/dpatch-run
Description: Fix for CVE-2014-8503 CVE-2014-8502 CVE-2014-8737
Author: Luciano Bello <luciano@debian.org>
Origin: backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=32a9d621c3c480aa093a089a36e36c35f68a4010
        backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=690725fa0d98ae52c991f4b3ea58b6b47b4fbc80
        backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=a5c71af8d3c7c535f27614947f72883233658706
Applied-Upstream: commit:32a9d621c3c480aa093a089a36e36c35f68a4010
                  commit:690725fa0d98ae52c991f4b3ea58b6b47b4fbc80
                  commit:a5c71af8d3c7c535f27614947f72883233658706
---
@DPATCH@
--- a/bfd/aoutx.h
+++ b/bfd/aoutx.h
@@ -1296,14 +1296,14 @@ aout_get_external_symbols (bfd *abfd)
     {
       bfd_size_type count;
       struct external_nlist *syms;
+      bfd_size_type amt = exec_hdr (abfd)->a_syms;
 
-      count = exec_hdr (abfd)->a_syms / EXTERNAL_NLIST_SIZE;
+      count = amt / EXTERNAL_NLIST_SIZE;
       if (count == 0)
 	return TRUE;		/* Nothing to do.  */
 
 #ifdef USE_MMAP
-      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd),
-				 exec_hdr (abfd)->a_syms,
+      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd), amt,
 				 &obj_aout_sym_window (abfd), TRUE))
 	return FALSE;
       syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;
@@ -1311,20 +1311,16 @@ aout_get_external_symbols (bfd *abfd)
       /* We allocate using malloc to make the values easy to free
 	 later on.  If we put them on the objalloc it might not be
 	 possible to free them.  */
-      syms = (struct external_nlist *) bfd_malloc (count * EXTERNAL_NLIST_SIZE);
+      syms = (struct external_nlist *) bfd_malloc (amt);
       if (syms == NULL)
 	return FALSE;
 
-      {
-	bfd_size_type amt;
-	amt = exec_hdr (abfd)->a_syms;
-	if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
-	    || bfd_bread (syms, amt, abfd) != amt)
-	  {
-	    free (syms);
-	    return FALSE;
-	  }
-      }
+      if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
+	  || bfd_bread (syms, amt, abfd) != amt)
+	{
+	  free (syms);
+	  return FALSE;
+	}
 #endif
 
       obj_aout_external_syms (abfd) = syms;
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -1279,6 +1279,8 @@ _bfd_slurp_extended_name_table (bfd *abf
 	{
 	byebye:
 	  bfd_release (abfd, namedata);
+          bfd_ardata (abfd)->extended_names = NULL;
+          bfd_ardata (abfd)->extended_names_size = 0;
 	  return FALSE;
 	}
 
--- a/bfd/coff-i386.c
+++ b/bfd/coff-i386.c
@@ -349,16 +349,18 @@ static reloc_howto_type howto_table[] =
 	 PCRELOFFSET)		/* pcrel_offset */
 };
 
+#define NUM_HOWTOS (sizeof (howto_table) / sizeof (howto_table[0]))
+
 /* Turn a howto into a reloc  nunmber */
 
 #define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
 #define BADMAG(x) I386BADMAG(x)
 #define I386 1			/* Customize coffcode.h */
 
-#define RTYPE2HOWTO(cache_ptr, dst)					\
-  ((cache_ptr)->howto =							\
-   ((dst)->r_type < sizeof (howto_table) / sizeof (howto_table[0])	\
-    ? howto_table + (dst)->r_type					\
+#define RTYPE2HOWTO(cache_ptr, dst)				\
+  ((cache_ptr)->howto =						\
+   ((dst)->r_type < NUM_HOWTOS					\
+    ? howto_table + (dst)->r_type				\
     : NULL))
 
 /* For 386 COFF a STYP_NOLOAD | STYP_BSS section is part of a shared
@@ -395,7 +397,8 @@ static reloc_howto_type howto_table[] =
       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
     else							\
       cache_ptr->addend = 0;					\
-    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+    if (ptr && reloc.r_type < NUM_HOWTOS			\
+	&& howto_table[reloc.r_type].pc_relative)		\
       cache_ptr->addend += asect->vma;				\
   }
 
@@ -455,7 +458,7 @@ coff_i386_rtype_to_howto (abfd, sec, rel
 {
   reloc_howto_type *howto;
 
-  if (rel->r_type >= sizeof (howto_table) / sizeof (howto_table[0]))
+  if (rel->r_type >= NUM_HOWTOS)
     {
       bfd_set_error (bfd_error_bad_value);
       return NULL;
@@ -592,7 +595,7 @@ coff_i386_reloc_name_lookup (bfd *abfd A
 {
   unsigned int i;
 
-  for (i = 0; i < sizeof (howto_table) / sizeof (howto_table[0]); i++)
+  for (i = 0; i < NUM_HOWTOS; i++)
     if (howto_table[i].name != NULL
 	&& strcasecmp (howto_table[i].name, r_name) == 0)
       return &howto_table[i];
--- a/bfd/coff-x86_64.c
+++ b/bfd/coff-x86_64.c
@@ -449,6 +449,8 @@ static reloc_howto_type howto_table[] =
 	 PCRELOFFSET)		/* pcrel_offset */
 };
 
+#define NUM_HOWTOS ARRAY_SIZE (howto_table)
+
 /* Turn a howto into a reloc  nunmber */
 
 #define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
@@ -457,7 +459,7 @@ static reloc_howto_type howto_table[] =
 
 #define RTYPE2HOWTO(cache_ptr, dst)		\
   ((cache_ptr)->howto =				\
-   ((dst)->r_type < ARRAY_SIZE (howto_table))	\
+   ((dst)->r_type < NUM_HOWTOS)			\
     ? howto_table + (dst)->r_type		\
     : NULL)
 
@@ -497,7 +499,8 @@ static reloc_howto_type howto_table[] =
       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
     else							\
       cache_ptr->addend = 0;					\
-    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+    if (ptr && reloc.r_type < NUM_HOWTOS			\
+	&& howto_table[reloc.r_type].pc_relative)		\
       cache_ptr->addend += asect->vma;				\
   }
 
@@ -547,7 +550,7 @@ coff_amd64_rtype_to_howto (bfd *abfd ATT
 {
   reloc_howto_type *howto;
 
-  if (rel->r_type > ARRAY_SIZE (howto_table))
+  if (rel->r_type >= NUM_HOWTOS)
     {
       bfd_set_error (bfd_error_bad_value);
       return NULL;
@@ -689,7 +692,7 @@ coff_amd64_reloc_name_lookup (bfd *abfd
 {
   unsigned int i;
 
-  for (i = 0; i < sizeof (howto_table) / sizeof (howto_table[0]); i++)
+  for (i = 0; i < NUM_HOWTOS; i++)
     if (howto_table[i].name != NULL
 	&& strcasecmp (howto_table[i].name, r_name) == 0)
       return &howto_table[i];
--- a/bfd/coffcode.h
+++ b/bfd/coffcode.h
@@ -339,6 +339,9 @@ CODE_FRAGMENT
 .    union internal_auxent auxent;
 .    struct internal_syment syment;
 .  } u;
+.
+. {* Selector for the union above.  *}
+. bfd_boolean is_sym;
 .} combined_entry_type;
 .
 .
@@ -1778,6 +1781,7 @@ coff_new_section_hook (bfd * abfd, asect
      in case this symbol winds up getting written out.  The value 0
      for n_numaux is already correct.  */
 
+  native->is_sym = TRUE;
   native->u.syment.n_type = T_NULL;
   native->u.syment.n_sclass = sclass;
 
@@ -2485,11 +2489,13 @@ coff_pointerize_aux_hook (bfd *abfd ATTR
 			  unsigned int indaux,
 			  combined_entry_type *aux)
 {
+  BFD_ASSERT (symbol->is_sym);
   int n_sclass = symbol->u.syment.n_sclass;
 
   if (CSECT_SYM_P (n_sclass)
       && indaux + 1 == symbol->u.syment.n_numaux)
     {
+      BFD_ASSERT (! aux->is_sym);
       if (SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp) == XTY_LD)
 	{
 	  aux->u.auxent.x_csect.x_scnlen.p =
@@ -2522,6 +2528,7 @@ coff_pointerize_aux_hook (bfd *abfd ATTR
   /* Return TRUE if we don't want to pointerize this aux entry, which
      is the case for the lastfirst aux entry for a C_LEAFPROC symbol.  */
   return (indaux == 1
+          && symbbol->is_sym
 	  && (symbol->u.syment.n_sclass == C_LEAFPROC
 	      || symbol->u.syment.n_sclass == C_LEAFSTAT
 	      || symbol->u.syment.n_sclass == C_LEAFEXT));
@@ -2544,6 +2551,8 @@ coff_print_aux (bfd *abfd ATTRIBUTE_UNUS
 		combined_entry_type *aux ATTRIBUTE_UNUSED,
 		unsigned int indaux ATTRIBUTE_UNUSED)
 {
+  BFD_ASSERT (symbol->is_sym);
+  BFD_ASSERT (! aux->is_sym);
 #ifdef RS6000COFF_C
   if (CSECT_SYM_P (symbol->u.syment.n_sclass)
       && indaux + 1 == symbol->u.syment.n_numaux)
@@ -3164,6 +3173,7 @@ coff_compute_section_file_positions (bfd
 	  cf = coff_symbol_from (abfd, *symp);
 	  if (cf != NULL
 	      && cf->native != NULL
+	      && cf->native->is_sym
 	      && SYMNAME_IN_DEBUG (&cf->native->u.syment))
 	    {
 	      size_t len;
@@ -3859,6 +3869,7 @@ coff_write_object_contents (bfd * abfd)
 		  csym = coff_symbol_from (abfd, *psym);
 		  if (csym == NULL
 		      || csym->native == NULL
+		      || ! csym->native->is_sym
 		      || csym->native->u.syment.n_numaux < 1
 		      || csym->native->u.syment.n_sclass != C_STAT
 		      || csym->native->u.syment.n_type != T_NULL)
@@ -3881,6 +3892,7 @@ coff_write_object_contents (bfd * abfd)
 		 x_associated field is not currently supported.  */
 
 	      aux = csym->native + 1;
+	      BFD_ASSERT (! aux->is_sym);
 	      switch (current->flags & SEC_LINK_DUPLICATES)
 		{
 		case SEC_LINK_DUPLICATES_DISCARD:
@@ -4533,6 +4545,7 @@ coff_slurp_line_table (bfd *abfd, asecti
 
       if (cache_ptr->line_number == 0)
 	{
+	  combined_entry_type * ent;
 	  bfd_boolean warned;
 	  bfd_signed_vma symndx;
 	  coff_symbol_type *sym;
@@ -4550,11 +4563,25 @@ coff_slurp_line_table (bfd *abfd, asecti
 	      warned = TRUE;
 	    }
 
+	  ent = obj_raw_syments (abfd) + symndx;
 	  /* FIXME: We should not be casting between ints and
 	     pointers like this.  */
-	  sym = ((coff_symbol_type *)
-		 ((symndx + obj_raw_syments (abfd))
-		  ->u.syment._n._n_n._n_zeroes));
+          if (! ent->is_sym)
+            {
+              (*_bfd_error_handler)
+                 (_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+                 abfd, (long) symndx, counter);
+              cache_ptr->line_number = -1;
+             continue;
+            }
+          sym = (coff_symbol_type *) (ent->u.syment._n._n_n._n_zeroes);
+
+          /* PR 17512 file: 078-10659-0.004  */
+          if (sym < obj_symbols (abfd)
+              || sym > obj_symbols (abfd)
+              + obj_raw_syment_count (abfd) * sizeof (coff_symbol_type))
+            sym = NULL;
+
 	  cache_ptr->u.sym = (asymbol *) sym;
 	  if (sym->lineno != NULL && ! warned)
 	    (*_bfd_error_handler)
@@ -4675,6 +4702,8 @@ coff_slurp_symbol_table (bfd * abfd)
 	  table_ptr[this_index] = number_of_symbols;
 	  dst->symbol.the_bfd = abfd;
 
+	  BFD_ASSERT (src->is_sym);
+
 	  dst->symbol.name = (char *) (src->u.syment._n._n_n._n_offset);
 	  /* We use the native name field to point to the cached field.  */
 	  src->u.syment._n._n_n._n_zeroes = (bfd_hostptr_t) dst;
@@ -5129,6 +5158,7 @@ SUBSUBSECTION
     else if (ptr)						\
       coffsym = coff_symbol_from (abfd, ptr);			\
     if (coffsym != NULL						\
+	&& coffsym->native->is_sym                              \
 	&& coffsym->native->u.syment.n_scnum == 0)		\
       cache_ptr->addend = 0;					\
     else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
--- a/bfd/coffgen.c
+++ b/bfd/coffgen.c
@@ -694,6 +694,7 @@ coff_renumber_symbols (bfd *bfd_ptr, int
 	  combined_entry_type *s = coff_symbol_ptr->native;
 	  int i;
 
+	  BFD_ASSERT (s->is_sym);
 	  if (s->u.syment.n_sclass == C_FILE)
 	    {
 	      if (last_file != NULL)
@@ -738,6 +739,7 @@ coff_mangle_symbols (bfd *bfd_ptr)
 	  int i;
 	  combined_entry_type *s = coff_symbol_ptr->native;
 
+	  BFD_ASSERT (s->is_sym);
 	  if (s->fix_value)
 	    {
 	      /* FIXME: We should use a union here.  */
@@ -761,6 +763,8 @@ coff_mangle_symbols (bfd *bfd_ptr)
 	  for (i = 0; i < s->u.syment.n_numaux; i++)
 	    {
 	      combined_entry_type *a = s + i + 1;
+
+	      BFD_ASSERT (! a->is_sym);
 	      if (a->fix_tag)
 		{
 		  a->u.auxent.x_sym.x_tagndx.l =
@@ -804,6 +808,7 @@ coff_fix_symbol_name (bfd *abfd,
     }
   name_length = strlen (name);
 
+  BFD_ASSERT (native->is_sym);
   if (native->u.syment.n_sclass == C_FILE
       && native->u.syment.n_numaux > 0)
     {
@@ -819,6 +824,7 @@ coff_fix_symbol_name (bfd *abfd,
       else
   	strncpy (native->u.syment._n._n_name, ".file", SYMNMLEN);
 
+      BFD_ASSERT (! (native + 1)->is_sym);
       auxent = &(native + 1)->u.auxent;
 
       filnmlen = bfd_coff_filnmlen (abfd);
@@ -921,6 +927,8 @@ coff_write_symbol (bfd *abfd,
   void * buf;
   bfd_size_type symesz;
 
+  BFD_ASSERT (native->is_sym);
+
   if (native->u.syment.n_sclass == C_FILE)
     symbol->flags |= BSF_DEBUGGING;
 
@@ -961,6 +969,7 @@ coff_write_symbol (bfd *abfd,
 	return FALSE;
       for (j = 0; j < native->u.syment.n_numaux; j++)
 	{
+	  BFD_ASSERT (! (native + j + 1)->is_sym);
 	  bfd_coff_swap_aux_out (abfd,
 				 &((native + j + 1)->u.auxent),
 				 type, n_sclass, (int) j,
@@ -998,6 +1007,8 @@ coff_write_alien_symbol (bfd *abfd,
 			       : symbol->section;
 
   native = &dummy;
+  native->is_sym = TRUE;
+  native[1].is_sym = FALSE;
   native->u.syment.n_type = T_NULL;
   native->u.syment.n_flags = 0;
   if (bfd_is_und_section (symbol->section))
@@ -1062,6 +1073,7 @@ coff_write_native_symbol (bfd *abfd,
   combined_entry_type *native = symbol->native;
   alent *lineno = symbol->lineno;
 
+  BFD_ASSERT (native->is_sym);
   /* If this symbol has an associated line number, we must store the
      symbol index in the line number field.  We also tag the auxent to
      point to the right place in the lineno table.  */
@@ -1171,6 +1183,7 @@ coff_write_symbols (bfd *abfd)
 		 symbol which has no associated section and we do not have to
 		 worry about this, all we need to know is that it is local.  */
 	      current_error_handler = bfd_set_error_handler (null_error_handler);
+	      BFD_ASSERT (c_symbol->native->is_sym);
 	      sym_class = bfd_coff_classify_symbol (abfd,
                                                    &c_symbol->native->u.syment);
 	      (void) bfd_set_error_handler (current_error_handler);
@@ -1263,6 +1276,9 @@ coff_write_symbols (bfd *abfd)
 	       file name, nor does it go in the .debug section.  */
 	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
 
+	  else if (! c_symbol->native->is_sym)
+            maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
+
 	  else if (bfd_coff_symname_in_debug (abfd,
 					      &c_symbol->native->u.syment))
 	    /* This symbol name is in the XCOFF .debug section.
@@ -1400,6 +1416,8 @@ coff_pointerize_aux (bfd *abfd,
   unsigned int type = symbol->u.syment.n_type;
   unsigned int n_sclass = symbol->u.syment.n_sclass;
 
+  BFD_ASSERT (symbol->is_sym);
+
   if (coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
     {
       if ((*coff_backend_info (abfd)->_bfd_coff_pointerize_aux_hook)
@@ -1413,6 +1431,7 @@ coff_pointerize_aux (bfd *abfd,
   if (n_sclass == C_FILE)
     return;
 
+  BFD_ASSERT (! auxent->is_sym);
   /* Otherwise patch up.  */
 #define N_TMASK coff_data  (abfd)->local_n_tmask
 #define N_BTSHFT coff_data (abfd)->local_n_btshft
@@ -1666,6 +1685,7 @@ coff_get_normalized_symtab (bfd *abfd)
       bfd_coff_swap_sym_in (abfd, (void *) raw_src,
 			    (void *) & internal_ptr->u.syment);
       symbol_ptr = internal_ptr;
+      internal_ptr->is_sym = TRUE;
 
       for (i = 0;
 	   i < symbol_ptr->u.syment.n_numaux;
@@ -1678,6 +1698,7 @@ coff_get_normalized_symtab (bfd *abfd)
 				symbol_ptr->u.syment.n_sclass,
 				(int) i, symbol_ptr->u.syment.n_numaux,
 				&(internal_ptr->u.auxent));
+	  internal_ptr->is_sym = FALSE;
 	  coff_pointerize_aux (abfd, internal, symbol_ptr, i,
 			       internal_ptr);
 	}
@@ -1691,12 +1712,17 @@ coff_get_normalized_symtab (bfd *abfd)
   for (internal_ptr = internal; internal_ptr < internal_end;
        internal_ptr++)
     {
+      BFD_ASSERT (internal_ptr->is_sym);
+
       if (internal_ptr->u.syment.n_sclass == C_FILE
 	  && internal_ptr->u.syment.n_numaux > 0)
 	{
+	  combined_entry_type * aux = internal_ptr + 1;
 	  /* Make a file symbol point to the name in the auxent, since
 	     the text ".file" is redundant.  */
-	  if ((internal_ptr + 1)->u.auxent.x_file.x_n.x_zeroes == 0)
+	  BFD_ASSERT (! aux->is_sym);
+
+	  if (aux->u.auxent.x_file.x_n.x_zeroes == 0)
 	    {
 	      /* The filename is a long one, point into the string table.  */
 	      if (string_table == NULL)
@@ -1808,7 +1834,7 @@ coff_make_empty_symbol (bfd *abfd)
   if (new_symbol == NULL)
     return NULL;
   new_symbol->symbol.section = 0;
-  new_symbol->native = 0;
+  new_symbol->native = NULL;
   new_symbol->lineno = NULL;
   new_symbol->done_lineno = FALSE;
   new_symbol->symbol.the_bfd = abfd;
@@ -1834,6 +1860,7 @@ coff_bfd_make_debug_symbol (bfd *abfd,
   new_symbol->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
   if (!new_symbol->native)
     return NULL;
+  new_symbol->native->is_sym = TRUE;
   new_symbol->symbol.section = bfd_abs_section_ptr;
   new_symbol->symbol.flags = BSF_DEBUGGING;
   new_symbol->lineno = NULL;
@@ -1849,7 +1876,8 @@ coff_get_symbol_info (bfd *abfd, asymbol
   bfd_symbol_info (symbol, ret);
 
   if (coffsymbol (symbol)->native != NULL
-      && coffsymbol (symbol)->native->fix_value)
+      && coffsymbol (symbol)->native->fix_value
+      && coffsymbol (symbol)->native->is_sym)
     ret->value = coffsymbol (symbol)->native->u.syment.n_value -
       (bfd_hostptr_t) obj_raw_syments (abfd);
 }
@@ -1864,7 +1892,8 @@ bfd_coff_get_syment (bfd *abfd,
   coff_symbol_type *csym;
 
   csym = coff_symbol_from (abfd, symbol);
-  if (csym == NULL || csym->native == NULL)
+  if (csym == NULL || csym->native == NULL
+      || ! csym->native->is_sym)
     {
       bfd_set_error (bfd_error_invalid_operation);
       return FALSE;
@@ -1896,6 +1925,7 @@ bfd_coff_get_auxent (bfd *abfd,
 
   if (csym == NULL
       || csym->native == NULL
+      || ! csym->native->is_sym
       || indx >= csym->native->u.syment.n_numaux)
     {
       bfd_set_error (bfd_error_invalid_operation);
@@ -1904,6 +1934,7 @@ bfd_coff_get_auxent (bfd *abfd,
 
   ent = csym->native + indx + 1;
 
+  BFD_ASSERT (! ent->is_sym);
   *pauxent = ent->u.auxent;
 
   if (ent->fix_tag)
@@ -1957,6 +1988,7 @@ coff_print_symbol (bfd *abfd,
 
 	  fprintf (file, "[%3ld]", (long) (combined - root));
 
+	  BFD_ASSERT (combined->is_sym);
 	  if (! combined->fix_value)
 	    val = (bfd_vma) combined->u.syment.n_value;
 	  else
@@ -1976,6 +2008,7 @@ coff_print_symbol (bfd *abfd,
 	      combined_entry_type *auxp = combined + aux + 1;
 	      long tagndx;
 
+	      BFD_ASSERT (! auxp->is_sym);
 	      if (auxp->fix_tag)
 		tagndx = auxp->u.auxent.x_sym.x_tagndx.p - root;
 	      else
@@ -2141,6 +2174,7 @@ coff_find_nearest_line (bfd *abfd,
   pend = p + cof->raw_syment_count;
   while (p < pend)
     {
+      BFD_ASSERT (p->is_sym);
       if (p->u.syment.n_sclass == C_FILE)
 	break;
       p += 1 + p->u.syment.n_numaux;
@@ -2164,6 +2198,7 @@ coff_find_nearest_line (bfd *abfd,
 	       p2 < pend;
 	       p2 += 1 + p2->u.syment.n_numaux)
 	    {
+	      BFD_ASSERT (p2->is_sym);
 	      if (p2->u.syment.n_scnum > 0
 		  && (section
 		      == coff_section_from_bfd_index (abfd,
@@ -2175,6 +2210,8 @@ coff_find_nearest_line (bfd *abfd,
 		  break;
 		}
 	    }
+          if (p2 >= pend)
+            break;
 
 	  file_addr = (bfd_vma) p2->u.syment.n_value;
 	  /* PR 11512: Include the section address of the function name symbol.  */
@@ -2239,6 +2276,8 @@ coff_find_nearest_line (bfd *abfd,
 	      if (coff->native)
 		{
 		  combined_entry_type *s = coff->native;
+
+		  BFD_ASSERT (s->is_sym);
 		  s = s + 1 + s->u.syment.n_numaux;
 
 		  /* In XCOFF a debugging symbol can follow the
@@ -2355,6 +2394,7 @@ bfd_coff_set_symbol_class (bfd *
       if (native == NULL)
 	return FALSE;
 
+      native->is_sym = TRUE;
       native->u.syment.n_type   = T_NULL;
       native->u.syment.n_sclass = symbol_class;
 
--- a/bfd/cofflink.c
+++ b/bfd/cofflink.c
@@ -2002,6 +2002,10 @@ _bfd_coff_link_input_bfd (struct coff_fi
 			    return FALSE;
 			}
 		      filename = strings + auxp->x_file.x_n.x_offset;
+                      if ((bfd_size_type) auxp->x_file.x_n.x_offset >= obj_coff_strings_len (input_bfd))
+                        filename = _("<corrupt>");
+                      else
+                        filename = strings + auxp->x_file.x_n.x_offset;
 		      indx = _bfd_stringtab_add (finfo->strtab, filename,
 						 hash, copy);
 		      if (indx == (bfd_size_type) -1)
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -1585,23 +1585,57 @@ bfd_section_from_shdr (bfd *abfd, unsign
   Elf_Internal_Ehdr *ehdr;
   const struct elf_backend_data *bed;
   const char *name;
+  bfd_boolean ret = TRUE;
+  static bfd_boolean * sections_being_created = NULL;
+  static bfd * sections_being_created_abfd = NULL;
+  static unsigned int nesting = 0;
 
   if (shindex >= elf_numsections (abfd))
     return FALSE;
 
+  if (++ nesting > 3)
+    {
+      /* PR17512: A corrupt ELF binary might contain a recursive group of
+         sections, each the string indicies pointing to the next in the
+         loop.  Detect this here, by refusing to load a section that we are
+         already in the process of loading.  We only trigger this test if
+         we have nested at least three sections deep as normal ELF binaries
+         can expect to recurse at least once.
+
+         FIXME: It would be better if this array was attached to the bfd,
+         rather than being held in a static pointer.  */
+
+      if (sections_being_created_abfd != abfd)
+        sections_being_created = NULL;
+      if (sections_being_created == NULL)
+        {
+          /* FIXME: It would be more efficient to attach this array to the bfd somehow.  */
+          sections_being_created = (bfd_boolean *)
+            bfd_zalloc (abfd, elf_numsections (abfd) * sizeof (bfd_boolean));
+          sections_being_created_abfd = abfd;
+        }
+      if (sections_being_created [shindex])
+        {
+          (*_bfd_error_handler)
+            (_("%B: warning: loop in section dependencies detected"), abfd);
+          return FALSE;
+        }
+      sections_being_created [shindex] = TRUE;
+    }
+
   hdr = elf_elfsections (abfd)[shindex];
   ehdr = elf_elfheader (abfd);
   name = bfd_elf_string_from_elf_section (abfd, ehdr->e_shstrndx,
 					  hdr->sh_name);
   if (name == NULL)
-    return FALSE;
+    goto fail;
 
   bed = get_elf_backend_data (abfd);
   switch (hdr->sh_type)
     {
     case SHT_NULL:
       /* Inactive section. Throw it away.  */
-      return TRUE;
+      goto success;
 
     case SHT_PROGBITS:	/* Normal section with contents.  */
     case SHT_NOBITS:	/* .bss section.  */
@@ -1612,11 +1646,12 @@ bfd_section_from_shdr (bfd *abfd, unsign
     case SHT_PREINIT_ARRAY:	/* .preinit_array section.  */
     case SHT_GNU_LIBLIST:	/* .gnu.liblist section.  */
     case SHT_GNU_HASH:		/* .gnu.hash section.  */
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_DYNAMIC:	/* Dynamic linking information.  */
       if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
-	return FALSE;
+        goto fail;
       if (hdr->sh_link > elf_numsections (abfd))
 	{
 	  /* PR 10478: Accept Solaris binaries with a sh_link
@@ -1630,11 +1665,11 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		break;
 	      /* Otherwise fall through.  */
 	    default:
-	      return FALSE;
+	      goto fail;
 	    }
 	}
       else if (elf_elfsections (abfd)[hdr->sh_link] == NULL)
-	return FALSE;
+	goto fail;
       else if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
 	{
 	  Elf_Internal_Shdr *dynsymhdr;
@@ -1663,16 +1698,16 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		}
 	    }
 	}
-      break;
+      goto success;
 
     case SHT_SYMTAB:		/* A symbol table */
       if (elf_onesymtab (abfd) == shindex)
-	return TRUE;
+	goto success;
 
       if (hdr->sh_entsize != bed->s->sizeof_sym)
-	return FALSE;
+	goto fail;
       if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
-	return FALSE;
+	goto fail;
       BFD_ASSERT (elf_onesymtab (abfd) == 0);
       elf_onesymtab (abfd) = shindex;
       elf_tdata (abfd)->symtab_hdr = *hdr;
@@ -1689,7 +1724,7 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	  && (abfd->flags & DYNAMIC) != 0
 	  && ! _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						shindex))
-	return FALSE;
+	goto fail;
 
       /* Go looking for SHT_SYMTAB_SHNDX too, since if there is one we
 	 can't read symbols without that section loaded as well.  It
@@ -1715,16 +1750,16 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		  break;
 	      }
 	  if (i != shindex)
-	    return bfd_section_from_shdr (abfd, i);
+	    ret = bfd_section_from_shdr (abfd, i);
 	}
-      return TRUE;
+      goto success;
 
     case SHT_DYNSYM:		/* A dynamic symbol table */
       if (elf_dynsymtab (abfd) == shindex)
-	return TRUE;
+	goto success;
 
       if (hdr->sh_entsize != bed->s->sizeof_sym)
-	return FALSE;
+	goto fail;
       BFD_ASSERT (elf_dynsymtab (abfd) == 0);
       elf_dynsymtab (abfd) = shindex;
       elf_tdata (abfd)->dynsymtab_hdr = *hdr;
@@ -1733,11 +1768,12 @@ bfd_section_from_shdr (bfd *abfd, unsign
 
       /* Besides being a symbol table, we also treat this as a regular
 	 section, so that objcopy can handle it.  */
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_SYMTAB_SHNDX:	/* Symbol section indices when >64k sections */
       if (elf_symtab_shndx (abfd) == shindex)
-	return TRUE;
+        goto success;
 
       BFD_ASSERT (elf_symtab_shndx (abfd) == 0);
       elf_symtab_shndx (abfd) = shindex;
@@ -1747,19 +1783,19 @@ bfd_section_from_shdr (bfd *abfd, unsign
 
     case SHT_STRTAB:		/* A string table */
       if (hdr->bfd_section != NULL)
-	return TRUE;
+        goto success;
       if (ehdr->e_shstrndx == shindex)
 	{
 	  elf_tdata (abfd)->shstrtab_hdr = *hdr;
 	  elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->shstrtab_hdr;
-	  return TRUE;
+          goto success;
 	}
       if (elf_elfsections (abfd)[elf_onesymtab (abfd)]->sh_link == shindex)
 	{
 	symtab_strtab:
 	  elf_tdata (abfd)->strtab_hdr = *hdr;
 	  elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->strtab_hdr;
-	  return TRUE;
+	  goto success;
 	}
       if (elf_elfsections (abfd)[elf_dynsymtab (abfd)]->sh_link == shindex)
 	{
@@ -1769,8 +1805,9 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	  elf_elfsections (abfd)[shindex] = hdr;
 	  /* We also treat this as a regular section, so that objcopy
 	     can handle it.  */
-	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
+	  ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						  shindex);
+          goto success;
 	}
 
       /* If the string table isn't one of the above, then treat it as a
@@ -1788,9 +1825,9 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		{
 		  /* Prevent endless recursion on broken objects.  */
 		  if (i == shindex)
-		    return FALSE;
+                    goto fail;
 		  if (! bfd_section_from_shdr (abfd, i))
-		    return FALSE;
+                    goto fail;
 		  if (elf_onesymtab (abfd) == i)
 		    goto symtab_strtab;
 		  if (elf_dynsymtab (abfd) == i)
@@ -1798,7 +1835,8 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		}
 	    }
 	}
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_REL:
     case SHT_RELA:
@@ -1813,7 +1851,7 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	if (hdr->sh_entsize
 	    != (bfd_size_type) (hdr->sh_type == SHT_REL
 				? bed->s->sizeof_rel : bed->s->sizeof_rela))
-	  return FALSE;
+          goto fail;
 
 	/* Check for a bogus link to avoid crashing.  */
 	if (hdr->sh_link >= num_sec)
@@ -1821,8 +1859,9 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	    ((*_bfd_error_handler)
 	     (_("%B: invalid link %lu for reloc section %s (index %u)"),
 	      abfd, hdr->sh_link, name, shindex));
-	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
+	    ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						    shindex);
+            goto success;
 	  }
 
 	/* For some incomprehensible reason Oracle distributes
@@ -1863,7 +1902,7 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	if ((elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_SYMTAB
 	     || elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_DYNSYM)
 	    && ! bfd_section_from_shdr (abfd, hdr->sh_link))
-	  return FALSE;
+          goto fail;
 
 	/* If this reloc section does not use the main symbol table we
 	   don't treat it as a reloc section.  BFD can't adequately
@@ -1878,14 +1917,15 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	    || hdr->sh_info >= num_sec
 	    || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_REL
 	    || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)
-	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
+          { ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						  shindex);
+          goto success; }
 
 	if (! bfd_section_from_shdr (abfd, hdr->sh_info))
-	  return FALSE;
+          goto fail;
 	target_sect = bfd_section_from_elf_index (abfd, hdr->sh_info);
 	if (target_sect == NULL)
-	  return FALSE;
+          goto fail;
 
 	esdt = elf_section_data (target_sect);
 	if (hdr->sh_type == SHT_RELA)
@@ -1897,7 +1937,7 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	    amt = sizeof (*hdr2);
 	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
 	    if (hdr2 == NULL)
-	      return FALSE;
+	      goto fail;
 	    elf_section_data (target_sect)->rel_hdr2 = hdr2;
 	  }
 	*hdr2 = *hdr;
@@ -1913,34 +1953,37 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	      target_sect->use_rela_p = 1;
 	  }
 	abfd->flags |= HAS_RELOC;
-	return TRUE;
+        goto success;
       }
 
     case SHT_GNU_verdef:
       elf_dynverdef (abfd) = shindex;
       elf_tdata (abfd)->dynverdef_hdr = *hdr;
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_GNU_versym:
       if (hdr->sh_entsize != sizeof (Elf_External_Versym))
-	return FALSE;
+        goto fail;
       elf_dynversym (abfd) = shindex;
       elf_tdata (abfd)->dynversym_hdr = *hdr;
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_GNU_verneed:
       elf_dynverref (abfd) = shindex;
       elf_tdata (abfd)->dynverref_hdr = *hdr;
-      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+      goto success;
 
     case SHT_SHLIB:
-      return TRUE;
+      goto success;
 
     case SHT_GROUP:
       if (! IS_VALID_GROUP_SECTION_HEADER (hdr))
-	return FALSE;
+        goto fail;
       if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
-	return FALSE;
+        goto fail;
       if (hdr->contents != NULL)
 	{
 	  Elf_Internal_Group *idx = (Elf_Internal_Group *) hdr->contents;
@@ -1966,7 +2009,7 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		}
 	    }
 	}
-      break;
+      goto success;
 
     default:
       /* Possibly an attributes section.  */
@@ -1974,14 +2017,14 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	  || hdr->sh_type == bed->obj_attrs_section_type)
 	{
 	  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
-	    return FALSE;
+            goto fail;
 	  _bfd_elf_parse_attributes (abfd, hdr);
-	  return TRUE;
+          goto success;
 	}
 
       /* Check for any processor-specific section types.  */
       if (bed->elf_backend_section_from_shdr (abfd, hdr, name, shindex))
-	return TRUE;
+        goto success;
 
       if (hdr->sh_type >= SHT_LOUSER && hdr->sh_type <= SHT_HIUSER)
 	{
@@ -1993,9 +2036,12 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		 "specific section `%s' [0x%8x]"),
 	       abfd, name, hdr->sh_type);
 	  else
+            {
 	    /* Allow sections reserved for applications.  */
-	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
+	    ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
 						    shindex);
+            goto success;
+            }
 	}
       else if (hdr->sh_type >= SHT_LOPROC
 	       && hdr->sh_type <= SHT_HIPROC)
@@ -2016,8 +2062,11 @@ bfd_section_from_shdr (bfd *abfd, unsign
 		 "`%s' [0x%8x]"),
 	       abfd, name, hdr->sh_type);
 	  else
+            {
 	    /* Otherwise it should be processed.  */
-	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+	    ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
+	    goto success;
+            }
 	}
       else
 	/* FIXME: We should handle this section.  */
@@ -2025,10 +2074,17 @@ bfd_section_from_shdr (bfd *abfd, unsign
 	  (_("%B: don't know how to handle section `%s' [0x%8x]"),
 	   abfd, name, hdr->sh_type);
 
-      return FALSE;
+      goto fail;
     }
 
-  return TRUE;
+ fail:
+  ret = FALSE;
+ success:
+  if (sections_being_created)
+    sections_being_created [shindex] = FALSE;
+  if (-- nesting == 0)
+    sections_being_created = NULL;
+  return ret;
 }
 
 /* Return the local symbol specified by ABFD, R_SYMNDX.  */
@@ -7018,8 +7074,12 @@ _bfd_elf_slurp_version_tables (bfd *abfd
 
       hdr = &elf_tdata (abfd)->dynverref_hdr;
 
-      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)
+      if (hdr->sh_info)
+	elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)
           bfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));
+      else
+	elf_tdata (abfd)->verref = NULL;
+	
       if (elf_tdata (abfd)->verref == NULL)
 	goto error_return;
 
@@ -7179,8 +7239,12 @@ error_return_verref:
 	  else
 	    freeidx = ++maxidx;
 	}
-      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
+      if (maxidx)
+	elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
           bfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));
+      else
+	elf_tdata (abfd)->verdef = NULL;
+
       if (elf_tdata (abfd)->verdef == NULL)
 	goto error_return;
 
@@ -7321,16 +7385,12 @@ asymbol *
 _bfd_elf_make_empty_symbol (bfd *abfd)
 {
   elf_symbol_type *newsym;
-  bfd_size_type amt = sizeof (elf_symbol_type);
 
-  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
+  newsym = (elf_symbol_type *) bfd_zalloc (abfd, sizeof * newsym);
   if (!newsym)
     return NULL;
-  else
-    {
-      newsym->symbol.the_bfd = abfd;
-      return &newsym->symbol;
-    }
+  newsym->symbol.the_bfd = abfd;
+  return &newsym->symbol;
 }
 
 void
@@ -9010,7 +9070,7 @@ elfcore_write_lwpstatus (bfd *abfd,
   lwpstat.pr_lwpid  = pid >> 16;
   lwpstat.pr_cursig = cursig;
 #if defined (HAVE_LWPSTATUS_T_PR_REG)
-  memcpy (lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
+  memcpy (&lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
 #elif defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
 #if !defined(gregs)
   memcpy (lwpstat.pr_context.uc_mcontext.gregs,
--- a/bfd/ieee.c
+++ b/bfd/ieee.c
@@ -1313,7 +1313,8 @@ ieee_archive_p (bfd *abfd)
 
   /* Ignore the return value here.  It doesn't matter if we don't read
      the entire buffer.  We might have a very small ieee file.  */
-  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);
+  if (bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd) <= 0)
+    goto got_wrong_format_error;
 
   ieee->h.first_byte = buffer;
   ieee->h.input_p = buffer;
@@ -1802,7 +1803,8 @@ ieee_object_p (bfd *abfd)
     goto fail;
   /* Read the first few bytes in to see if it makes sense.  Ignore
      bfd_bread return value;  The file might be very small.  */
-  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);
+  if (bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd) <= 0)
+    goto got_wrong_format;
 
   ieee->h.input_p = buffer;
   if (this_byte_and_next (&(ieee->h)) != Module_Beginning)
--- a/bfd/libcoff-in.h
+++ b/bfd/libcoff-in.h
@@ -37,6 +37,7 @@
 #define obj_coff_external_syms(bfd)   (coff_data (bfd)->external_syms)
 #define obj_coff_keep_syms(bfd)	      (coff_data (bfd)->keep_syms)
 #define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
+#define obj_coff_strings_len(bfd)     (coff_data (bfd)->strings_len)
 #define obj_coff_keep_strings(bfd)    (coff_data (bfd)->keep_strings)
 #define obj_coff_sym_hashes(bfd)      (coff_data (bfd)->sym_hashes)
 #define obj_coff_strings_written(bfd) (coff_data (bfd)->strings_written)
@@ -77,6 +78,8 @@ typedef struct coff_tdata
   /* The string table.  May be NULL.  Read by
      _bfd_coff_read_string_table.  */
   char *strings;
+  /* The length of the strings table.  For error checking.  */
+  bfd_size_type strings_len;
   /* If this is TRUE, the strings may not be freed.  */
   bfd_boolean keep_strings;
   /* If this is TRUE, the strings have been written out already.  */
--- a/bfd/libcoff.h
+++ b/bfd/libcoff.h
@@ -41,6 +41,7 @@
 #define obj_coff_external_syms(bfd)   (coff_data (bfd)->external_syms)
 #define obj_coff_keep_syms(bfd)	      (coff_data (bfd)->keep_syms)
 #define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
+#define obj_coff_strings_len(bfd)     (coff_data (bfd)->strings_len)
 #define obj_coff_keep_strings(bfd)    (coff_data (bfd)->keep_strings)
 #define obj_coff_sym_hashes(bfd)      (coff_data (bfd)->sym_hashes)
 #define obj_coff_strings_written(bfd) (coff_data (bfd)->strings_written)
@@ -81,6 +82,8 @@ typedef struct coff_tdata
   /* The string table.  May be NULL.  Read by
      _bfd_coff_read_string_table.  */
   char *strings;
+  /* The length of the strings table.  For error checking.  */
+  bfd_size_type strings_len;
   /* If this is TRUE, the strings may not be freed.  */
   bfd_boolean keep_strings;
   /* If this is TRUE, the strings have been written out already.  */
@@ -613,7 +616,7 @@ extern bfd_boolean ppc_process_before_al
 typedef struct coff_ptr_struct
 {
   /* Remembers the offset from the first symbol in the file for
-     this symbol. Generated by coff_renumber_symbols. */
+     this symbol. Generated by coff_renumber_symbols.  */
   unsigned int offset;
 
   /* Should the value of this symbol be renumbered.  Used for
@@ -621,15 +624,15 @@ typedef struct coff_ptr_struct
   unsigned int fix_value : 1;
 
   /* Should the tag field of this symbol be renumbered.
-     Created by coff_pointerize_aux. */
+     Created by coff_pointerize_aux.  */
   unsigned int fix_tag : 1;
 
   /* Should the endidx field of this symbol be renumbered.
-     Created by coff_pointerize_aux. */
+     Created by coff_pointerize_aux.  */
   unsigned int fix_end : 1;
 
   /* Should the x_csect.x_scnlen field be renumbered.
-     Created by coff_pointerize_aux. */
+     Created by coff_pointerize_aux.  */
   unsigned int fix_scnlen : 1;
 
   /* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
@@ -637,12 +640,15 @@ typedef struct coff_ptr_struct
   unsigned int fix_line : 1;
 
   /* The container for the symbol structure as read and translated
-     from the file. */
+     from the file.  */
   union
   {
     union internal_auxent auxent;
     struct internal_syment syment;
   } u;
+
+ /* Selector for the union above.  */
+ bfd_boolean is_sym;
 } combined_entry_type;
 
 
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -916,14 +916,19 @@ void *
 bfd_alloc (bfd *abfd, bfd_size_type size)
 {
   void *ret;
+  unsigned long ul_size = (unsigned long) size;
 
-  if (size != (unsigned long) size)
+  if (size != ul_size
+      /* A small negative size can result in objalloc_alloc allocating just
+	 1 byte of memory, but the caller will be expecting more.  So catch
+	 this case here.  */
+      || (size != 0 && (((ul_size + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1)) == 0)))
     {
       bfd_set_error (bfd_error_no_memory);
       return NULL;
     }
-
-  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
+							
+  ret = objalloc_alloc ((struct objalloc *) abfd->memory, ul_size);
   if (ret == NULL)
     bfd_set_error (bfd_error_no_memory);
   return ret;
@@ -944,8 +949,6 @@ DESCRIPTION
 void *
 bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)
 {
-  void *ret;
-
   if ((nmemb | size) >= HALF_BFD_SIZE_TYPE
       && size != 0
       && nmemb > ~(bfd_size_type) 0 / size)
@@ -954,18 +957,7 @@ bfd_alloc2 (bfd *abfd, bfd_size_type nme
       return NULL;
     }
 
-  size *= nmemb;
-
-  if (size != (unsigned long) size)
-    {
-      bfd_set_error (bfd_error_no_memory);
-      return NULL;
-    }
-
-  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
-  if (ret == NULL)
-    bfd_set_error (bfd_error_no_memory);
-  return ret;
+  return bfd_alloc (abfd, size * nmemb);
 }
 
 /*
@@ -1154,7 +1146,7 @@ get_debug_link_info (bfd *abfd, unsigned
   asection *sect;
   unsigned long crc32;
   bfd_byte *contents;
-  int crc_offset;
+  unsigned int crc_offset;
   char *name;
 
   BFD_ASSERT (abfd);
@@ -1172,10 +1164,15 @@ get_debug_link_info (bfd *abfd, unsigned
       return NULL;
     }
 
-  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
+  /* CRC value is stored after the filename, aligned up to 4 bytes.  */
   name = (char *) contents;
-  crc_offset = strlen (name) + 1;
+  /* PR 17597: avoid reading off the end of the buffer.  */
+  crc_offset = strnlen (name, bfd_get_section_size (sect)) + 1;
+  if (crc_offset >= bfd_get_section_size (sect))
+    return NULL;
   crc_offset = (crc_offset + 3) & ~3;
+  if (crc_offset >= bfd_get_section_size (sect))
+    return NULL;
 
   crc32 = bfd_get_32 (abfd, contents + crc_offset);
 
--- a/bfd/pe-mips.c
+++ b/bfd/pe-mips.c
@@ -341,6 +341,8 @@ static reloc_howto_type howto_table[] =
 	 FALSE),                /* Pcrel_offset. */
 };
 
+#define NUM_HOWTOS (sizeof (howto_table) / sizeof (howto_table[0]))
+
 /* Turn a howto into a reloc nunmber.  */
 
 #define SELECT_RELOC(x, howto) { x.r_type = howto->type; }
@@ -381,7 +383,8 @@ static reloc_howto_type howto_table[] =
       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
     else							\
       cache_ptr->addend = 0;					\
-    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+    if (ptr && reloc.r_type < NUM_HOWTOS			\
+	&& howto_table[reloc.r_type].pc_relative)		\
       cache_ptr->addend += asect->vma;				\
   }
 
@@ -511,9 +514,7 @@ coff_mips_reloc_name_lookup (bfd *abfd A
 {
   unsigned int i;
 
-  for (i = 0;
-       i < sizeof (howto_table) / sizeof (howto_table[0]);
-       i++)
+  for (i = 0; i < NUM_HOWTOS; i++)
     if (howto_table[i].name != NULL
 	&& strcasecmp (howto_table[i].name, r_name) == 0)
       return &howto_table[i];
--- a/bfd/peXXigen.c
+++ b/bfd/peXXigen.c
@@ -142,8 +142,13 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void *
 
 	  name = _bfd_coff_internal_syment_name (abfd, in, namebuf);
 	  if (name == NULL)
-	    /* FIXME: Return error.  */
-	    abort ();
+	    {
+	      _bfd_error_handler (_("%B: unable to find name for empty section"),
+				  abfd);
+	      bfd_set_error (bfd_error_invalid_target);
+	      return;
+	    }
+
 	  sec = bfd_get_section_by_name (abfd, name);
 	  if (sec != NULL)
 	    in->n_scnum = sec->target_index;
@@ -163,15 +168,22 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void *
 	    {
 	      name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1);
 	      if (name == NULL)
-		/* FIXME: Return error.  */
-		abort ();
+		{
+		  _bfd_error_handler (_("%B: out of memory creating name for empty section"),
+				      abfd);
+		  return;
+		}
 	      strcpy ((char *) name, namebuf);
 	    }
+
 	  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;
 	  sec = bfd_make_section_anyway_with_flags (abfd, name, flags);
 	  if (sec == NULL)
-	    /* FIXME: Return error.  */
-	    abort ();
+	    {
+	      _bfd_error_handler (_("%B: unable to create fake empty section"),
+				  abfd);
+	      return;
+	    }
 
 	  sec->vma = 0;
 	  sec->lma = 0;
@@ -240,6 +252,9 @@ _bfd_XXi_swap_aux_in (bfd *	abfd,
   AUXENT *ext = (AUXENT *) ext1;
   union internal_auxent *in = (union internal_auxent *) in1;
 
+  /* PR 17521: Make sure that all fields in the aux structure
+     are initialised.  */
+  memset (in, 0, sizeof * in);
   switch (in_class)
     {
     case C_FILE:
@@ -415,6 +430,7 @@ _bfd_XXi_swap_aouthdr_in (bfd * abfd,
   aouthdr_int->entry = GET_AOUTHDR_ENTRY (abfd, aouthdr_ext->entry);
   aouthdr_int->text_start =
     GET_AOUTHDR_TEXT_START (abfd, aouthdr_ext->text_start);
+
 #if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
   /* PE32+ does not have data_start member!  */
   aouthdr_int->data_start =
@@ -462,7 +478,7 @@ _bfd_XXi_swap_aouthdr_in (bfd * abfd,
     int idx;
 
     /* PR 17512: Corrupt PE binaries can cause seg-faults.  */
-    if (a->NumberOfRvaAndSizes > 16)
+    if (a->NumberOfRvaAndSizes > IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
       {
        (*_bfd_error_handler)
          (_("%B: aout header specifies an invalid number of data-directory entries: %d"),
@@ -486,6 +502,13 @@ _bfd_XXi_swap_aouthdr_in (bfd * abfd,
 	else
 	  a->DataDirectory[idx].VirtualAddress = 0;
       }
+
+    while (idx < IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
+      {
+	a->DataDirectory[idx].Size = 0;
+	a->DataDirectory[idx].VirtualAddress = 0;
+	idx ++;
+      }
   }
 
   if (aouthdr_int->entry)
@@ -732,7 +755,7 @@ _bfd_XXi_swap_aouthdr_out (bfd * abfd, v
   {
     int idx;
 
-    for (idx = 0; idx < 16; idx++)
+    for (idx = 0; idx < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; idx++)
       {
 	H_PUT_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
 		  aouthdr_out->DataDirectory[idx][0]);
@@ -1226,7 +1249,9 @@ pe_print_idata (bfd * abfd, void * vfile
         break;
 
       dll = (char *) data + dll_name - adj;
-      fprintf (file, _("\n\tDLL Name: %s\n"), dll);
+      /* PR 17512 file: 078-12277-0.004.  */
+      bfd_size_type maxlen = (char *)(data + datasize) - dll - 1;
+      fprintf (file, _("\n\tDLL Name: %.*s\n"), (int) maxlen, dll);
 
       if (hint_addr != 0)
 	{
@@ -1291,23 +1316,30 @@ pe_print_idata (bfd * abfd, void * vfile
 #ifdef COFF_WITH_pex64
 	  for (j = 0; idx + j + 8 <= datasize; j += 8)
 	    {
+              bfd_size_type amt;
 	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
 	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);
 
 	      if (!member && !member_high)
 		break;
 
+	      amt = member - adj;
+
 	      if (member_high & 0x80000000)
 		fprintf (file, "\t%lx%08lx\t %4lx%08lx  <none>",
 			 member_high,member, member_high & 0x7fffffff, member);
+              /* PR binutils/17512: Handle corrupt PE data.  */
+              else if (amt + 2 >= datasize)
+                fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
 	      else
 		{
 		  int ordinal;
 		  char *member_name;
 
-		  ordinal = bfd_get_16 (abfd, data + member - adj);
-		  member_name = (char *) data + member - adj + 2;
-		  fprintf (file, "\t%04lx\t %4d  %s",member, ordinal, member_name);
+                  ordinal = bfd_get_16 (abfd, data + amt);
+                  member_name = (char *) data + amt + 2;
+                  fprintf (file, "\t%04lx\t %4d  %.*s",member, ordinal,
+                           (int) (datasize - (amt + 2)), member_name);
 		}
 
 	      /* If the time stamp is not zero, the import address
@@ -1323,24 +1355,30 @@ pe_print_idata (bfd * abfd, void * vfile
 #else
 	  for (j = 0; j < datasize; j += 4)
 	    {
+	      bfd_size_type amt;
 	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
 
 	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */ 
 	      if (member == 0)
 		break;
 
+              amt = member - adj;
 	      if (member & 0x80000000)
 		fprintf (file, "\t%04lx\t %4lu  <none>",
 			 member, member & 0x7fffffff);
+              /* PR binutils/17512: Handle corrupt PE data.  */
+              else if (amt + 2 >= datasize)
+                fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
 	      else
 		{
 		  int ordinal;
 		  char *member_name;
 
-		  ordinal = bfd_get_16 (abfd, data + member - adj);
-		  member_name = (char *) data + member - adj + 2;
-		  fprintf (file, "\t%04lx\t %4d  %s",
-			   member, ordinal, member_name);
+                  ordinal = bfd_get_16 (abfd, data + amt);
+                  member_name = (char *) data + amt + 2;
+                  fprintf (file, "\t%04lx\t %4d  %.*s",
+                           member, ordinal,
+                           (int) (datasize - (amt + 2)), member_name);
 		}
 
 	      /* If the time stamp is not zero, the import address
@@ -1438,6 +1476,15 @@ pe_print_edata (bfd * abfd, void * vfile
 	}
     }
 
+   /* PR 17512: Handle corrupt PE binaries.  */
+   if (datasize < 36)
+     {
+       fprintf (file,
+               _("\nThere is an export table in %s, but it is too small (%d)\n"),
+               section->name, (int) datasize);
+       return TRUE;
+     }
+
   fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
 	   section->name, (unsigned long) addr);
 
@@ -1481,8 +1528,9 @@ pe_print_edata (bfd * abfd, void * vfile
   fprintf (file,
 	   _("Name \t\t\t\t"));
   bfd_fprintf_vma (abfd, file, edt.name);
-  fprintf (file,
-	   " %s\n", data + edt.name - adj);
+  fprintf (file, " %.*s\n",
+           (int) (datasize - (edt.name - adj)),
+           data + edt.name - adj);
 
   fprintf (file,
 	   _("Ordinal Base \t\t\t%ld\n"), edt.base);
@@ -1528,7 +1576,14 @@ pe_print_edata (bfd * abfd, void * vfile
 	  _("\nExport Address Table -- Ordinal Base %ld\n"),
 	  edt.base);
 
-  for (i = 0; i < edt.num_functions; ++i)
+    /* PR 17512: Handle corrupt PE binaries.  */
+    if (edt.eat_addr + (edt.num_functions * 4) - adj >= datasize
+       /* PR 17512 file: 140-165018-0.004.  */
+       || data + edt.eat_addr - adj < data)
+       fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
+              (long) edt.eat_addr,
+              (long) edt.num_functions);
+    else for (i = 0; i < edt.num_functions; ++i)
     {
       bfd_vma eat_member = bfd_get_32 (abfd,
 				       data + edt.eat_addr + (i * 4) - adj);
@@ -1540,11 +1595,12 @@ pe_print_edata (bfd * abfd, void * vfile
 	  /* This rva is to a name (forwarding function) in our section.  */
 	  /* Should locate a function descriptor.  */
 	  fprintf (file,
-		   "\t[%4ld] +base[%4ld] %04lx %s -- %s\n",
+		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
 		   (long) i,
 		   (long) (i + edt.base),
 		   (unsigned long) eat_member,
 		   _("Forwarder RVA"),
+		   (int)(datasize - (eat_member - adj)),
 		   data + eat_member - adj);
 	}
       else
@@ -1564,21 +1620,39 @@ pe_print_edata (bfd * abfd, void * vfile
   fprintf (file,
 	   _("\n[Ordinal/Name Pointer] Table\n"));
 
-  for (i = 0; i < edt.num_names; ++i)
+  /* PR 17512: Handle corrupt PE binaries.  */
+  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize
+      || (data + edt.npt_addr - adj) < data)
+    fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
+             (long) edt.npt_addr,
+             (long) edt.num_names);
+  /* PR 17512: file: 140-147171-0.004.  */
+  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
+           || data + edt.ot_addr - adj < data)
+    fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
+             (long) edt.ot_addr,
+             (long) edt.num_names);
+  else for (i = 0; i < edt.num_names; ++i)
     {
-      bfd_vma name_ptr = bfd_get_32 (abfd,
-				    data +
-				    edt.npt_addr
-				    + (i*4) - adj);
-
-      char *name = (char *) data + name_ptr - adj;
-
-      bfd_vma ord = bfd_get_16 (abfd,
-				    data +
-				    edt.ot_addr
-				    + (i*2) - adj);
-      fprintf (file,
-	      "\t[%4ld] %s\n", (long) ord, name);
+      bfd_vma  name_ptr;
+      bfd_vma  ord;
+
+      ord = bfd_get_16 (abfd, data + edt.ot_addr + (i * 2) - adj);
+      name_ptr = bfd_get_32 (abfd, data + edt.npt_addr + (i * 4) - adj);
+
+      if ((name_ptr - adj) >= datasize)
+       {
+         fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
+                  (long) ord, (long) name_ptr);
+       }
+      else
+       {
+         char * name = (char *) data + name_ptr - adj;
+
+         fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
+                  (int)((char *)(data + datasize) - name), name);
+       }
+
     }
 
   free (data);
@@ -1640,6 +1714,14 @@ pe_print_pdata (bfd * abfd, void * vfile
   if (datasize == 0)
     return TRUE;
 
+   /* PR 17512: file: 002-193900-0.004.  */
+   if (datasize < stop)
+     {
+       fprintf (file, _("Virtual size of .pdata section (%ld) larger than real size (%ld)\n"),
+               (long) stop, (long) datasize);
+       return FALSE;
+     }
+
   if (! bfd_malloc_and_get_section (abfd, section, &data))
     {
       if (data != NULL)
@@ -1819,6 +1901,14 @@ _bfd_XX_print_ce_compressed_pdata (bfd *
   if (datasize == 0)
     return TRUE;
 
+   /* PR 17512: file: 002-193900-0.004.  */
+   if (datasize < stop)
+     {
+       fprintf (file, _("Virtual size of .pdata section (%ld) larger than real size (%ld)\n"),
+               (long) stop, (long) datasize);
+       return FALSE;
+     }
+
   if (! bfd_malloc_and_get_section (abfd, section, &data))
     {
       if (data != NULL)
--- a/bfd/peicode.h
+++ b/bfd/peicode.h
@@ -264,6 +264,7 @@ pe_mkobject (bfd * abfd)
   /* in_reloc_p is architecture dependent.  */
   pe->in_reloc_p = in_reloc_p;
 
+  memset (& pe->pe_opthdr, 0, sizeof pe->pe_opthdr);
   return TRUE;
 }
 
@@ -560,6 +561,7 @@ pe_ILF_make_a_symbol (pe_ILF_vars *  var
   ent->u.syment.n_sclass          = sclass;
   ent->u.syment.n_scnum           = section->target_index;
   ent->u.syment._n._n_n._n_offset = (bfd_hostptr_t) sym;
+  ent->is_sym = TRUE;
 
   sym->symbol.the_bfd = vars->abfd;
   sym->symbol.name    = vars->string_ptr;
--- a/bfd/tekhex.c
+++ b/bfd/tekhex.c
@@ -247,11 +247,12 @@ struct tekhex_data_list_struct
 typedef struct tekhex_data_list_struct tekhex_data_list_type;
 
 #define CHUNK_MASK 0x1fff
+#define CHUNK_SPAN 32
 
 struct data_struct
 {
-  char chunk_data[CHUNK_MASK + 1];
-  char chunk_init[CHUNK_MASK + 1];
+  unsigned char chunk_data[CHUNK_MASK + 1];
+  unsigned char chunk_init[(CHUNK_MASK + 1 + CHUNK_SPAN - 1) / CHUNK_SPAN];
   bfd_vma vma;
   struct data_struct *next;
 };
@@ -313,7 +314,7 @@ getsym (char *dstp, char **srcp, unsigne
 }
 
 static struct data_struct *
-find_chunk (bfd *abfd, bfd_vma vma)
+find_chunk (bfd *abfd, bfd_vma vma, bfd_boolean create)
 {
   struct data_struct *d = abfd->tdata.tekhex_data->data;
 
@@ -321,7 +322,7 @@ find_chunk (bfd *abfd, bfd_vma vma)
   while (d && (d->vma) != vma)
     d = d->next;
 
-  if (!d)
+  if (!d && create)
     {
       /* No chunk for this address, so make one up.  */
       d = (struct data_struct *)
@@ -340,11 +341,14 @@ find_chunk (bfd *abfd, bfd_vma vma)
 static void
 insert_byte (bfd *abfd, int value, bfd_vma addr)
 {
-  /* Find the chunk that this byte needs and put it in.  */
-  struct data_struct *d = find_chunk (abfd, addr);
+  if (value != 0)
+    {
+      /* Find the chunk that this byte needs and put it in.  */
+      struct data_struct *d = find_chunk (abfd, addr, TRUE);
 
-  d->chunk_data[addr & CHUNK_MASK] = value;
-  d->chunk_init[addr & CHUNK_MASK] = 1;
+      d->chunk_data[addr & CHUNK_MASK] = value;
+      d->chunk_init[(addr & CHUNK_MASK) / CHUNK_SPAN] = 1;
+    }
 }
 
 /* The first pass is to find the names of all the sections, and see
@@ -404,6 +408,9 @@ first_phase (bfd *abfd, int type, char *
 	      if (!getvalue (&src, &val))
 		return FALSE;
 	      section->size = val - section->vma;
+              /* PR binutils/17512: Make sure that the size is sane.  */
+              if (section->size > (bfd_size_type) bfd_get_size (abfd))
+                return FALSE;
 	      section->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC;
 	      break;
 	    case '0':
@@ -590,22 +597,26 @@ move_section_contents (bfd *abfd,
       /* Get high bits of address.  */
       bfd_vma chunk_number = addr & ~(bfd_vma) CHUNK_MASK;
       bfd_vma low_bits = addr & CHUNK_MASK;
+      bfd_boolean must_write = !get && *location != 0;
 
-      if (chunk_number != prev_number)
-	/* Different chunk, so move pointer. */
-	d = find_chunk (abfd, chunk_number);
+      if (chunk_number != prev_number || (!d && must_write))
+	{
+	  /* Different chunk, so move pointer. */
+	  d = find_chunk (abfd, chunk_number, must_write);
+	  prev_number = chunk_number;
+	}
 
       if (get)
 	{
-	  if (d->chunk_init[low_bits])
+	  if (d)
 	    *location = d->chunk_data[low_bits];
 	  else
 	    *location = 0;
 	}
-      else
+      else if (must_write)
 	{
 	  d->chunk_data[low_bits] = *location;
-	  d->chunk_init[low_bits] = (*location != 0);
+	  d->chunk_init[low_bits / CHUNK_SPAN] = 1;
 	}
 
       location++;
@@ -633,7 +644,9 @@ tekhex_set_arch_mach (bfd *abfd,
 		      enum bfd_architecture arch,
 		      unsigned long machine)
 {
-  return bfd_default_set_arch_mach (abfd, arch, machine);
+  /* Ignore errors about unknown architecture.  */
+  return (bfd_default_set_arch_mach (abfd, arch, machine)
+	  || arch == bfd_arch_unknown);
 }
 
 /* We have to save up all the Tekhexords for a splurge before output.  */
@@ -645,24 +658,6 @@ tekhex_set_section_contents (bfd *abfd,
 			     file_ptr offset,
 			     bfd_size_type bytes_to_do)
 {
-  if (! abfd->output_has_begun)
-    {
-      /* The first time around, allocate enough sections to hold all the chunks.  */
-      asection *s = abfd->sections;
-      bfd_vma vma;
-
-      for (s = abfd->sections; s; s = s->next)
-	{
-	  if (s->flags & SEC_LOAD)
-	    {
-	      for (vma = s->vma & ~(bfd_vma) CHUNK_MASK;
-		   vma < s->vma + s->size;
-		   vma += CHUNK_MASK)
-		find_chunk (abfd, vma);
-	    }
-	}
-    }
-
   if (section->flags & (SEC_LOAD | SEC_ALLOC))
     {
       move_section_contents (abfd, section, locationp, offset, bytes_to_do,
@@ -773,26 +768,17 @@ tekhex_write_object_contents (bfd *abfd)
        d = d->next)
     {
       int low;
-
-      const int span = 32;
       int addr;
 
       /* Write it in blocks of 32 bytes.  */
-      for (addr = 0; addr < CHUNK_MASK + 1; addr += span)
+      for (addr = 0; addr < CHUNK_MASK + 1; addr += CHUNK_SPAN)
 	{
-	  int need = 0;
-
-	  /* Check to see if necessary.  */
-	  for (low = 0; !need && low < span; low++)
-	    if (d->chunk_init[addr + low])
-	      need = 1;
-
-	  if (need)
+	  if (d->chunk_init[addr / CHUNK_SPAN])
 	    {
 	      char *dst = buffer;
 
 	      writevalue (&dst, addr + d->vma);
-	      for (low = 0; low < span; low++)
+	      for (low = 0; low < CHUNK_SPAN; low++)
 		{
 		  TOHEX (dst, d->chunk_data[addr + low]);
 		  dst += 2;
--- a/bfd/xcofflink.c
+++ b/bfd/xcofflink.c
@@ -4496,7 +4496,10 @@ xcoff_link_input_bfd (struct xcoff_final
 			  if (strings == NULL)
 			    return FALSE;
 			}
-		      filename = strings + aux.x_file.x_n.x_offset;
+                      if ((bfd_size_type) aux.x_file.x_n.x_offset >= obj_coff_strings_len (input_bfd))
+                        filename = _("<corrupt>");
+                      else
+                        filename = strings + aux.x_file.x_n.x_offset;
 		      indx = _bfd_stringtab_add (finfo->strtab, filename,
 						 hash, copy);
 		      if (indx == (bfd_size_type) -1)
--- a/binutils/ar.c
+++ b/binutils/ar.c
@@ -938,6 +938,15 @@ extract_file (bfd *abfd)
   bfd_size_type size;
   struct stat buf;
 
+  /* PR binutils/17533: Do not allow directory traversal
+     outside of the current directory tree.  */
+  if (! is_valid_archive_path (bfd_get_filename (abfd)))
+    {
+      non_fatal (_("illegal pathname found in archive member: %s"),
+		 bfd_get_filename (abfd));
+      return;
+    }
+
   if (bfd_stat_arch_elt (abfd, &buf) != 0)
     /* xgettext:c-format */
     fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
--- a/binutils/bucomm.c
+++ b/binutils/bucomm.c
@@ -623,3 +623,29 @@ bfd_get_archive_filename (const bfd *abf
 	   bfd_get_filename (abfd));
   return buf;
 }
+
+/* Returns TRUE iff PATHNAME, a filename of an archive member,
+   is valid for writing.  For security reasons absolute paths
+   and paths containing /../ are not allowed.  See PR 17533.  */
+
+bfd_boolean
+is_valid_archive_path (char const * pathname)
+{
+  const char * n = pathname;
+
+  if (IS_ABSOLUTE_PATH (n))
+    return FALSE;
+
+  while (*n)
+    {
+      if (*n == '.' && *++n == '.' && ( ! *++n || IS_DIR_SEPARATOR (*n)))
+	return FALSE;
+
+      while (*n && ! IS_DIR_SEPARATOR (*n))
+	n++;
+      while (IS_DIR_SEPARATOR (*n))
+	n++;
+    }
+
+  return TRUE;
+}
--- a/binutils/bucomm.h
+++ b/binutils/bucomm.h
@@ -23,6 +23,8 @@
 #ifndef _BUCOMM_H
 #define _BUCOMM_H
 
+/* In bucomm.c.  */
+
 /* Return the filename in a static buffer.  */
 const char *bfd_get_archive_filename (const bfd *);
 
@@ -58,20 +60,22 @@ bfd_vma parse_vma (const char *, const c
 
 off_t get_file_size (const char *);
 
+bfd_boolean is_valid_archive_path (char const *);
+
 extern char *program_name;
 
-/* filemode.c */
+/* In filemode.c.  */
 void mode_string (unsigned long, char *);
 
-/* version.c */
+/* In version.c.  */
 extern void print_version (const char *);
 
-/* rename.c */
+/* In rename.c.  */
 extern void set_times (const char *, const struct stat *);
 
 extern int smart_rename (const char *, const char *, int);
 
-/* libiberty.  */
+/* In libiberty.  */
 void *xmalloc (size_t);
 
 void *xrealloc (void *, size_t);
--- a/binutils/doc/binutils.texi
+++ b/binutils/doc/binutils.texi
@@ -227,7 +227,8 @@ contents of each object would only waste
 are also @emph{flattened}, so that adding one or more archives to a
 thin archive will add the elements of the nested archive individually.
 The paths to the elements of the archive are stored relative to the
-archive itself.
+archive itself.  For security reasons absolute paths and paths with a
+@code{/../} component are not allowed.
 
 @cindex compatibility, @command{ar}
 @cindex @command{ar} compatibility
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -2051,6 +2051,16 @@ copy_archive (bfd *ibfd, bfd *obfd, cons
       bfd_boolean del = TRUE;
       bfd_boolean ok_object;
 
+      /* PR binutils/17533: Do not allow directory traversal
+	 outside of the current directory tree by archive members.  */
+      if (! is_valid_archive_path (bfd_get_filename (this_element)))
+	{
+	  non_fatal (_("illegal pathname found in archive member: %s"),
+		     bfd_get_filename (this_element));
+	  status = 1;
+	  return;
+	}
+
       /* Create an output file for this member.  */
       output_name = concat (dir, "/",
 			    bfd_get_filename (this_element), (char *) 0);
@@ -2060,8 +2070,12 @@ copy_archive (bfd *ibfd, bfd *obfd, cons
 	{
 	  output_name = make_tempdir (output_name);
 	  if (output_name == NULL)
-	    fatal (_("cannot create tempdir for archive copying (error: %s)"),
-		   strerror (errno));
+	    {
+	      non_fatal (_("cannot create tempdir for archive copying (error: %s)"),
+			 strerror (errno));
+	      status = 1;
+	      return;
+	    }
 
 	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
 	  l->name = output_name;
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -560,7 +560,10 @@ slurp_symtab (bfd *abfd)
 
   storage = bfd_get_symtab_upper_bound (abfd);
   if (storage < 0)
-    bfd_fatal (bfd_get_filename (abfd));
+    {
+      non_fatal (_("failed to read symbol table from: %s"), bfd_get_filename (abfd));
+      bfd_fatal (_("error message was"));
+    }
   if (storage)
     sy = (asymbol **) xmalloc (storage);
 
@@ -2363,7 +2366,12 @@ dump_dwarf (bfd *abfd)
   else if (bfd_little_endian (abfd))
     byte_get = byte_get_little_endian;
   else
-    abort ();
+    /* PR 17512: file: objdump-s-endless-loop.tekhex.  */
+    {
+      warn (_("File %s does not contain any dwarf debug information\n"),
+	    bfd_get_filename (abfd));
+      return;
+    }
 
   switch (bfd_get_arch (abfd))
     {
@@ -2463,7 +2471,7 @@ print_section_stabs (bfd *abfd,
 
      We start the index at -1 because there is a dummy symbol on
      the front of stabs-in-{coff,elf} sections that supplies sizes.  */
-  for (i = -1; stabp < stabs_end; stabp += STABSIZE, i++)
+  for (i = -1; stabp <= stabs_end - STABSIZE; stabp += STABSIZE, i++)
     {
       const char *name;
       unsigned long strx;
@@ -2501,10 +2509,13 @@ print_section_stabs (bfd *abfd,
 	}
       else
 	{
+	  bfd_size_type amt = strx + file_string_table_offset;
+
 	  /* Using the (possibly updated) string table offset, print the
 	     string (if any) associated with this symbol.  */
-	  if ((strx + file_string_table_offset) < stabstr_size)
-	    printf (" %s", &strtab[strx + file_string_table_offset]);
+	  if (amt < stabstr_size)
+	    /* PR 17512: file: 079-79389-0.001:0.1.  */
+	    printf (" %.*s", (int)(stabstr_size - amt), strtab + amt);
 	  else
 	    printf (" *");
 	}
@@ -3062,7 +3073,11 @@ dump_relocs_in_section (bfd *abfd,
   relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
 
   if (relcount < 0)
-    bfd_fatal (bfd_get_filename (abfd));
+    {
+      printf ("\n");
+      non_fatal (_("failed to read relocs in: %s"), bfd_get_filename (abfd));
+      bfd_fatal (_("error message was"));
+    }
   else if (relcount == 0)
     printf (" (none)\n\n");
   else
--- a/binutils/rdcoff.c
+++ b/binutils/rdcoff.c
@@ -84,7 +84,7 @@ struct coff_types
   debug_type basic[T_MAX + 1];
 };
 
-static debug_type *coff_get_slot (struct coff_types *, int);
+static debug_type *coff_get_slot (struct coff_types *, long);
 static debug_type parse_coff_type
   (bfd *, struct coff_symbols *, struct coff_types *, long, int,
    union internal_auxent *, bfd_boolean, void *);
@@ -105,12 +105,17 @@ static bfd_boolean external_coff_symbol_
 /* Return the slot for a type.  */
 
 static debug_type *
-coff_get_slot (struct coff_types *types, int indx)
+coff_get_slot (struct coff_types *types, long indx)
 {
   struct coff_slots **pps;
 
   pps = &types->slots;
 
+  /* PR 17512: file: 078-18333-0.001:0.1.
+     FIXME: The value of 1000 is a guess.  Maybe a better heuristic is needed.  */
+  if (indx / COFF_SLOTS > 1000)
+    fatal (_("Excessively large slot index: %lx"), indx);
+
   while (indx >= COFF_SLOTS)
     {
       if (*pps == NULL)
--- a/binutils/rddbg.c
+++ b/binutils/rddbg.c
@@ -140,7 +140,7 @@ read_section_stabs_debugging_info (bfd *
 	    }
 
 	  strsize = bfd_section_size (abfd, strsec);
-	  strings = (bfd_byte *) xmalloc (strsize);
+	  strings = (bfd_byte *) xmalloc (strsize + 1);
 	  if (! bfd_get_section_contents (abfd, strsec, strings, 0, strsize))
 	    {
 	      fprintf (stderr, "%s: %s: %s\n",
@@ -148,7 +148,8 @@ read_section_stabs_debugging_info (bfd *
 		       bfd_errmsg (bfd_get_error ()));
 	      return FALSE;
 	    }
-
+	  /* Zero terminate the strings table, just in case.  */
+	  strings [strsize] = 0;
 	  if (shandle == NULL)
 	    {
 	      shandle = start_stab (dhandle, abfd, TRUE, syms, symcount);
@@ -160,7 +161,8 @@ read_section_stabs_debugging_info (bfd *
 
 	  stroff = 0;
 	  next_stroff = 0;
-	  for (stab = stabs; stab < stabs + stabsize; stab += 12)
+	  /* PR 17512: file: 078-60391-0.001:0.1.  */
+	  for (stab = stabs; stab <= (stabs + stabsize) - 12; stab += 12)
 	    {
 	      unsigned int strx;
 	      int type;
@@ -185,33 +187,43 @@ read_section_stabs_debugging_info (bfd *
 		}
 	      else
 		{
+		  size_t len;
 		  char *f, *s;
 
-		  f = NULL;
-
-		  if (stroff + strx > strsize)
+		  if (stroff + strx >= strsize)
 		    {
-		      fprintf (stderr, "%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\n",
+		      fprintf (stderr, _("%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\n"),
 			       bfd_get_filename (abfd), names[i].secname,
 			       (long) (stab - stabs) / 12, strx, type);
 		      continue;
 		    }
 
 		  s = (char *) strings + stroff + strx;
+		  f = NULL;
 
-		  while (s[strlen (s) - 1] == '\\'
+		  /* PR 17512: file: 002-87578-0.001:0.1.
+		     It is possible to craft a file where, without the 'strlen (s) > 0',
+		     an attempt to read the byte before 'strings' would occur.  */
+		  while ((len = strlen (s)) > 0
+			 && s[len  - 1] == '\\'
 			 && stab + 12 < stabs + stabsize)
 		    {
 		      char *p;
 
 		      stab += 12;
-		      p = s + strlen (s) - 1;
+		      p = s + len - 1;
 		      *p = '\0';
-		      s = concat (s,
-				  ((char *) strings
-				   + stroff
-				   + bfd_get_32 (abfd, stab)),
-				  (const char *) NULL);
+		      strx = stroff + bfd_get_32 (abfd, stab);
+		      if (strx >= strsize)
+			{
+			  fprintf (stderr, _("%s: %s: stab entry %ld is corrupt\n"),
+				   bfd_get_filename (abfd), names[i].secname,
+				   (long) (stab - stabs) / 12);
+			  break;
+			}
+		      else
+			s = concat (s, (char *) strings + strx,
+				    (const char *) NULL);
 
 		      /* We have to restore the backslash, because, if
 			 the linker is hashing stabs strings, we may
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -157,9 +157,10 @@
 char * program_name = "readelf";
 static long archive_file_offset;
 static unsigned long archive_file_size;
+static bfd_size_type current_file_size;
 static unsigned long dynamic_addr;
 static bfd_size_type dynamic_size;
-static unsigned int dynamic_nent;
+static size_t dynamic_nent;
 static char * dynamic_strings;
 static unsigned long dynamic_strings_length;
 static char * string_table;
@@ -320,8 +332,9 @@ get_data (void * var, FILE * file, long
 
       if (mvar == NULL)
 	{
-	  error (_("Out of memory allocating 0x%lx bytes for %s\n"),
-		 (unsigned long)(size * nmemb), reason);
+	  if (reason)
+	    error (_("Out of memory allocating 0x%lx bytes for %s\n"),
+		   (unsigned long)(size * nmemb), reason);
 	  return NULL;
 	}
 
@@ -330,8 +343,9 @@ get_data (void * var, FILE * file, long
 
   if (fread (mvar, size, nmemb, file) != nmemb)
     {
-      error (_("Unable to read in 0x%lx bytes of %s\n"),
-	     (unsigned long)(size * nmemb), reason);
+      if (reason)
+	error (_("Unable to read in 0x%lx bytes of %s\n"),
+	       (unsigned long)(size * nmemb), reason);
       if (mvar != var)
 	free (mvar);
       return NULL;
@@ -409,6 +423,7 @@ print_symbol (int width, const char *sym
       width = - width;
       extra_padding = TRUE;
     }
+  assert (width != 0);
 
   while (width)
     {
@@ -474,6 +489,81 @@ print_symbol (int width, const char *sym
   return num_printed;
 }
 
+/* Returns a pointer to a static buffer containing a  printable version of
+   the given section's name.  Like print_symbol, except that it does not try
+   to print multibyte characters, it just interprets them as hex values.  */
+
+static const char *
+printable_section_name (Elf_Internal_Shdr * sec)
+{
+#define MAX_PRINT_SEC_NAME_LEN 128
+  static char  sec_name_buf [MAX_PRINT_SEC_NAME_LEN + 1];
+  const char * name = SECTION_NAME (sec);
+  char *       buf = sec_name_buf;
+  char         c;
+  unsigned int remaining = MAX_PRINT_SEC_NAME_LEN;
+
+  while ((c = * name ++) != 0)
+    {
+      if (ISCNTRL (c))
+	{
+	  if (remaining < 2)
+	    break;
+	  
+	  * buf ++ = '^';
+	  * buf ++ = c + 0x40;
+	  remaining -= 2;
+	}
+      else if (ISPRINT (c))
+	{
+	  * buf ++ = c;
+	  remaining -= 1;
+	}
+      else
+	{
+	  static char hex[17] = "0123456789ABCDEF";
+
+	  if (remaining < 4)
+	    break;
+	  * buf ++ = '<';
+	  * buf ++ = hex[(c & 0xf0) >> 4];
+	  * buf ++ = hex[c & 0x0f];
+	  * buf ++ = '>';
+	  remaining -= 4;
+	}
+
+      if (remaining == 0)
+	break;
+    }
+
+  * buf = 0;
+  return sec_name_buf;
+}
+
+static const char *
+printable_section_name_from_index (unsigned long ndx)
+{
+  if (ndx >= elf_header.e_shnum)
+    return _("<corrupt>");
+
+  return printable_section_name (section_headers + ndx);
+}
+
+static Elf_Internal_Shdr *
+find_section_by_type (unsigned int type)
+{
+  unsigned int i;
+
+  for (i = 0; i < elf_header.e_shnum; i++)
+    {
+      Elf_Internal_Shdr *sec = section_headers + i;
+      if (sec->sh_type == type)
+       return sec;
+    }
+
+  return NULL;
+}
+
 /* Return a pointer to section NAME, or NULL if no such section exists.  */
 
 static Elf_Internal_Shdr *
@@ -646,7 +736,7 @@ slurp_rela_relocs (FILE * file,
 		   unsigned long * nrelasp)
 {
   Elf_Internal_Rela * relas;
-  unsigned long nrelas;
+  size_t nrelas;
   unsigned int i;
 
   if (is_32bit_elf)
@@ -744,7 +834,7 @@ slurp_rel_relocs (FILE * file,
 		  unsigned long * nrelsp)
 {
   Elf_Internal_Rela * rels;
-  unsigned long nrels;
+  size_t nrels;
   unsigned int i;
 
   if (is_32bit_elf)
@@ -1318,8 +1408,7 @@ dump_relocations (FILE * file,
 		  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION)
 		    {
 		      if (psym->st_shndx < elf_header.e_shnum)
-			sec_name
-			  = SECTION_NAME (section_headers + psym->st_shndx);
+			sec_name = SECTION_NAME (section_headers + psym->st_shndx);
 		      else if (psym->st_shndx == SHN_ABS)
 			sec_name = "ABS";
 		      else if (psym->st_shndx == SHN_COMMON)
@@ -3583,21 +3672,31 @@ process_file_header (void)
   return 1;
 }
 
-
-static int
+static bfd_boolean
 get_32bit_program_headers (FILE * file, Elf_Internal_Phdr * program_headers)
 {
   Elf32_External_Phdr * phdrs;
   Elf32_External_Phdr * external;
   Elf_Internal_Phdr *   internal;
   unsigned int i;
+  unsigned int size = elf_header.e_phentsize;
+  unsigned int num  = elf_header.e_phnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return FALSE;
+  if (size < sizeof * phdrs)
+    {
+      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
+      return FALSE;
+    }
+  if (size > sizeof * phdrs)
+    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
 
   phdrs = (Elf32_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
-                                            elf_header.e_phentsize,
-                                            elf_header.e_phnum,
-                                            _("program headers"));
-  if (!phdrs)
-    return 0;
+                                            size, num, _("program headers"));
+  if (phdrs == NULL)
+    return FALSE;
 
   for (i = 0, internal = program_headers, external = phdrs;
        i < elf_header.e_phnum;
@@ -3614,20 +3713,32 @@ get_32bit_program_headers (FILE * file,
   return TRUE;
 }
 
-static int
+static bfd_boolean
 get_64bit_program_headers (FILE * file, Elf_Internal_Phdr * program_headers)
 {
   Elf64_External_Phdr * phdrs;
   Elf64_External_Phdr * external;
   Elf_Internal_Phdr *   internal;
   unsigned int i;
+  unsigned int size = elf_header.e_phentsize;
+  unsigned int num  = elf_header.e_phnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return FALSE;
+  if (size < sizeof * phdrs)
+    {
+      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
+      return FALSE;
+    }
+  if (size > sizeof * phdrs)
+    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
 
   phdrs = (Elf64_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
-                                            elf_header.e_phentsize,
-                                            elf_header.e_phnum,
-                                            _("program headers"));
+                                            size, num, _("program headers"));
+
   if (!phdrs)
-    return 0;
+    return FALSE;
 
   for (i = 0, internal = program_headers, external = phdrs;
        i < elf_header.e_phnum;
@@ -3648,8 +3757,7 @@ get_64bit_program_headers (FILE * file,
     }
 
   free (phdrs);
-
-  return 1;
+  return TRUE;
 }
 
 /* Returns 1 if the program headers were read into `program_headers'.  */
@@ -3668,7 +3776,8 @@ get_program_headers (FILE * file)
 
   if (phdrs == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory reading %u program headers\n"),
+	     elf_header.e_phnum);
       return 0;
     }
 
@@ -3824,6 +3933,9 @@ process_program_headers (FILE * file)
 	    }
 	}
 
+      if (do_segments)
+	putc ('\n', stdout);
+
       switch (segment->p_type)
 	{
 	case PT_DYNAMIC:
@@ -3834,6 +3946,12 @@ process_program_headers (FILE * file)
 	     section in the DYNAMIC segment.  */
 	  dynamic_addr = segment->p_offset;
 	  dynamic_size = segment->p_filesz;
+	  /* PR binutils/17512: Avoid corrupt dynamic section info in the segment.  */
+	  if (dynamic_addr + dynamic_size >= current_file_size)
+	    {
+	      error (_("the dynamic segment offset + size exceeds the size of the file\n"));
+	      dynamic_addr = dynamic_size = 0;
+	    }
 
 	  /* Try to locate the .dynamic section. If there is
 	     a section header table, we can easily locate it.  */
@@ -3887,14 +4005,11 @@ process_program_headers (FILE * file)
 		error (_("Unable to read program interpreter name\n"));
 
 	      if (do_segments)
-		printf (_("\n      [Requesting program interpreter: %s]"),
+		printf (_("      [Requesting program interpreter: %s]\n"),
 		    program_interpreter);
 	    }
 	  break;
 	}
-
-      if (do_segments)
-	putc ('\n', stdout);
     }
 
   if (do_segments && section_headers != NULL && string_table != NULL)
@@ -3916,7 +4031,7 @@ process_program_headers (FILE * file)
 	  for (j = 1; j < elf_header.e_shnum; j++, section++)
 	    {
 	      if (ELF_IS_SECTION_IN_SEGMENT_MEMORY (section, segment))
-		printf ("%s ", SECTION_NAME (section));
+                printf ("%s ", printable_section_name (section));
 	    }
 
 	  putc ('\n',stdout);
@@ -3958,26 +4073,46 @@ offset_from_vma (FILE * file, bfd_vma vm
 }
 
 
-static int
-get_32bit_section_headers (FILE * file, unsigned int num)
+/* Allocate memory and load the sections headers into the global pointer
+   SECTION_HEADERS.  If PROBE is true, this is just a probe and we do not
+   generate any error messages if the load fails.  */
+
+static bfd_boolean
+get_32bit_section_headers (FILE * file, bfd_boolean probe)
 {
   Elf32_External_Shdr * shdrs;
   Elf_Internal_Shdr *   internal;
   unsigned int i;
+  unsigned int size = elf_header.e_shentsize;
+  unsigned int num = probe ? 1 : elf_header.e_shnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return FALSE;
+  if (size < sizeof * shdrs)
+    {
+      if (! probe)
+	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
+      return FALSE;
+    }
+  if (!probe && size > sizeof * shdrs)
+    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
 
   shdrs = (Elf32_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
-                                            elf_header.e_shentsize, num,
-                                            _("section headers"));
-  if (!shdrs)
-    return 0;
+                                            size, num,
+					    probe ? NULL : _("section headers"));
+  if (shdrs == NULL)
+    return FALSE;
 
+  if (section_headers != NULL)
+    free (section_headers);
   section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                    sizeof (Elf_Internal_Shdr));
-
   if (section_headers == NULL)
     {
-      error (_("Out of memory\n"));
-      return 0;
+      if (!probe)
+	error (_("Out of memory reading %u section headers\n"), num);
+      return FALSE;
     }
 
   for (i = 0, internal = section_headers;
@@ -3997,30 +4132,45 @@ get_32bit_section_headers (FILE * file,
     }
 
   free (shdrs);
-
-  return 1;
+  return TRUE;
 }
 
-static int
-get_64bit_section_headers (FILE * file, unsigned int num)
+static bfd_boolean
+get_64bit_section_headers (FILE * file, bfd_boolean probe)
 {
   Elf64_External_Shdr * shdrs;
   Elf_Internal_Shdr *   internal;
   unsigned int i;
+  unsigned int size = elf_header.e_shentsize;
+  unsigned int num = probe ? 1 : elf_header.e_shnum;
+
+  /* PR binutils/17531: Cope with unexpected section header sizes.  */
+  if (size == 0 || num == 0)
+    return FALSE;
+  if (size < sizeof * shdrs)
+    {
+      if (! probe)
+	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
+      return FALSE;
+    }
+  if (! probe && size > sizeof * shdrs)
+    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
 
   shdrs = (Elf64_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
-                                            elf_header.e_shentsize, num,
-                                            _("section headers"));
-  if (!shdrs)
-    return 0;
+                                            size, num,
+					    probe ? NULL : _("section headers"));
+  if (shdrs == NULL)
+    return FALSE;
 
+  if (section_headers != NULL)
+    free (section_headers);
   section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                    sizeof (Elf_Internal_Shdr));
-
   if (section_headers == NULL)
     {
-      error (_("Out of memory\n"));
-      return 0;
+      if (! probe)
+	error (_("Out of memory reading %u section headers\n"), num);
+      return FALSE;
     }
 
   for (i = 0, internal = section_headers;
@@ -4040,8 +4190,7 @@ get_64bit_section_headers (FILE * file,
     }
 
   free (shdrs);
-
-  return 1;
+  return TRUE;
 }
 
 static Elf_Internal_Sym *
@@ -4061,6 +4210,13 @@ get_32bit_elf_symbols (FILE * file, Elf_
       return NULL;
     }
 
+  if (section->sh_size > current_file_size)
+    {
+      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
+	     printable_section_name (section), (unsigned long) section->sh_size);
+      if (shndx) free (shndx); free (esyms); return NULL; /* one line due dpatch */
+    }
+
   number = section->sh_size / section->sh_entsize;
 
   if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
@@ -4074,7 +4230,6 @@ get_32bit_elf_symbols (FILE * file, Elf_
   if (esyms == NULL)
     return NULL;
 
-  shndx = NULL;
   if (symtab_shndx_hdr != NULL
       && (symtab_shndx_hdr->sh_link
 	  == (unsigned long) (section - section_headers)))
@@ -4144,6 +4298,13 @@ get_64bit_elf_symbols (FILE * file, Elf_
       return NULL;
     }
 
+  if (section->sh_size > current_file_size)
+    {
+      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
+	     printable_section_name (section), (unsigned long) section->sh_size);
+      goto exit_point;
+    }
+
   number = section->sh_size / section->sh_entsize;
 
   if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
@@ -4193,11 +4354,11 @@ get_64bit_elf_symbols (FILE * file, Elf_
       psym->st_size  = BYTE_GET (esyms[j].st_size);
     }
 
-  if (shndx)
-    free (shndx);
-  free (esyms);
-
-  return isyms;
+    exit_point:
+    if (shndx)
+      free (shndx);
+    free (esyms);
+    return isyms;
 }
 
 static const char *
@@ -4455,10 +4616,10 @@ process_section_headers (FILE * file)
 
   if (is_32bit_elf)
     {
-      if (! get_32bit_section_headers (file, elf_header.e_shnum))
+      if (! get_32bit_section_headers (file, FALSE))
 	return 0;
     }
-  else if (! get_64bit_section_headers (file, elf_header.e_shnum))
+  else if (! get_64bit_section_headers (file, FALSE))
     return 0;
 
   /* Read in the string table, so that we have names to display.  */
@@ -4648,7 +4809,6 @@ process_section_headers (FILE * file)
 	      )
 	    request_dump_bynumber (i, DEBUG_DUMP);
 	}
-
     }
 
   if (! do_sections)
@@ -4946,7 +5106,8 @@ process_section_groups (FILE * file)
 
   if (section_headers_groups == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory reading %u section group headers\n"),
+	     elf_header.e_shnum);
       return 0;
     }
 
@@ -4970,7 +5131,8 @@ process_section_groups (FILE * file)
 
   if (section_groups == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory reading %lu groups\n"),
+	     (unsigned long) group_count);
       return 0;
     }
 
@@ -4985,8 +5147,8 @@ process_section_groups (FILE * file)
     {
       if (section->sh_type == SHT_GROUP)
 	{
-	  char * name = SECTION_NAME (section);
-	  char * group_name;
+	  const char * name = printable_section_name (section);
+	  const char * group_name;
 	  unsigned char * start;
 	  unsigned char * indices;
 	  unsigned int entry, j, size;
@@ -5051,9 +5213,10 @@ process_section_groups (FILE * file)
 		  strtab_sec = sec;
 		  if (strtab)
 		    free (strtab);
+
 		  strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset,
-                                              1, strtab_sec->sh_size,
-                                              _("string table"));
+					      1, strtab_sec->sh_size,
+					      _("string table"));
 		  strtab_size = strtab != NULL ? strtab_sec->sh_size : 0;
 		}
 	      group_name = sym->st_name < strtab_size
@@ -5124,7 +5287,7 @@ process_section_groups (FILE * file)
 	      if (do_section_groups)
 		{
 		  sec = section_headers + entry;
-		  printf ("   [%5u]   %s\n", entry, SECTION_NAME (sec));
+		  printf ("   [%5u]   %s\n", entry, printable_section_name (sec));
 		}
 
 	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
@@ -5465,8 +5628,8 @@ process_relocs (FILE * file)
 		      strsec = section_headers + symsec->sh_link;
 
 		      strtab = (char *) get_data (NULL, file, strsec->sh_offset,
-                                                  1, strsec->sh_size,
-                                                  _("string table"));
+						  1, strsec->sh_size,
+						  _("string table"));
 		      strtablen = strtab == NULL ? 0 : strsec->sh_size;
 		    }
 
@@ -5770,6 +5933,11 @@ ia64_process_unwind (FILE * file)
 	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
 
 	  strsec = section_headers + sec->sh_link;
+          if (aux.strtab != NULL)
+            {
+              error (_("Multiple auxillary string tables encountered\n"));
+              free (aux.strtab);
+            }
 	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                           1, strsec->sh_size,
                                           _("string table"));
@@ -5788,13 +5955,16 @@ ia64_process_unwind (FILE * file)
       char * suffix;
       size_t len, len2;
 
-      for (i = unwstart, sec = section_headers + unwstart;
+      for (i = unwstart, sec = section_headers + unwstart, unwsec = NULL;
 	   i < elf_header.e_shnum; ++i, ++sec)
 	if (sec->sh_type == SHT_IA_64_UNWIND)
 	  {
 	    unwsec = sec;
 	    break;
 	  }
+      /* We have already counted the number of SHT_IA64_UNWIND
+	 sections so the loop above should never fail.  */
+      assert (unwsec != NULL);
 
       unwstart = i + 1;
       len = sizeof (ELF_STRING_ia64_unwind_once) - 1;
@@ -5802,18 +5972,26 @@ ia64_process_unwind (FILE * file)
       if ((unwsec->sh_flags & SHF_GROUP) != 0)
 	{
 	  /* We need to find which section group it is in.  */
-	  struct group_list * g = section_headers_groups [i]->root;
+	  struct group_list * g;
 
-	  for (; g != NULL; g = g->next)
+	  if (section_headers_groups == NULL
+	      || section_headers_groups [i] == NULL)
+	    i = elf_header.e_shnum;
+	  else
 	    {
-	      sec = section_headers + g->section_index;
+	      g = section_headers_groups [i]->root;
 
-	      if (streq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info))
-		break;
-	    }
+	      for (; g != NULL; g = g->next)
+		{
+		  sec = section_headers + g->section_index;
 
-	  if (g == NULL)
-	    i = elf_header.e_shnum;
+		  if (streq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info))
+		    break;
+		}
+
+	      if (g == NULL)
+		i = elf_header.e_shnum;
+	    }
 	}
       else if (strneq (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind_once, len))
 	{
@@ -5849,9 +6027,9 @@ ia64_process_unwind (FILE * file)
 	  if (string_table == NULL)
 	    printf ("%d", unwsec->sh_name);
 	  else
-	    printf (_("'%s'"), SECTION_NAME (unwsec));
+	    printf ("'%s'", printable_section_name (unwsec));
 	}
       else
 	{
 	  aux.info_addr = sec->sh_addr;
 	  aux.info = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1,
@@ -5864,7 +6042,7 @@ ia64_process_unwind (FILE * file)
 	  if (string_table == NULL)
 	    printf ("%d", unwsec->sh_name);
 	  else
-	    printf (_("'%s'"), SECTION_NAME (unwsec));
+	    printf ("'%s'", printable_section_name (unwsec));
 
 	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
 		  (unsigned long) unwsec->sh_offset,
@@ -6184,6 +6362,11 @@ hppa_process_unwind (FILE * file)
 	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
 
 	  strsec = section_headers + sec->sh_link;
+	  if (aux.strtab != NULL)
+	    {
+	      error (_("Multiple auxillary string tables encountered\n"));
+	      free (aux.strtab);
+	    }
 	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                           1, strsec->sh_size,
                                           _("string table"));
@@ -6201,10 +6383,8 @@ hppa_process_unwind (FILE * file)
     {
       if (streq (SECTION_NAME (sec), ".PARISC.unwind"))
 	{
-	  printf (_("\nUnwind section "));
-	  printf (_("'%s'"), SECTION_NAME (sec));
-
-	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
+	  printf (_("\nUnwind section '%s' at offset 0x%lx contains %lu entries:\n"),
+		  printable_section_name (sec),
 		  (unsigned long) sec->sh_offset,
 		  (unsigned long) (sec->sh_size / (2 * eh_addr_size + 8)));
 
@@ -6299,6 +6479,9 @@ arm_section_get_word (struct arm_unw_aux
   unsigned int word;
   bfd_boolean wrapped;
 
+  if (sec == NULL || arm_sec == NULL)
+    return FALSE;
+
   addr->section = SHN_UNDEF;
   addr->offset = 0;
 
@@ -6396,7 +6579,9 @@ arm_section_get_word (struct arm_unw_aux
 	  continue;
 	}
 
-      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
+      /* PR 17531: file: 027-161405-0.004  */
+      if (aux->symtab == NULL)
+	continue;
 
       if (arm_sec->rel_type == SHT_REL)
 	{
@@ -6407,6 +6592,7 @@ arm_section_get_word (struct arm_unw_aux
       else
 	offset = rp->r_addend;
 
+      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
       offset += sym->st_value;
       prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);
 
@@ -7069,6 +7255,13 @@ arm_process_unwind (FILE *file)
 	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
 
 	  strsec = section_headers + sec->sh_link;
+
+	  /* PR binutils/17531 file: 011-12666-0.004.  */
+	  if (aux.strtab != NULL)
+	    {
+	      error (_("Multiple string tables found in file.\n"));
+	      free (aux.strtab);
+	    }
 	  aux.strtab = get_data (NULL, file, strsec->sh_offset,
 				 1, strsec->sh_size, _("string table"));
 	  aux.strtab_size = aux.strtab != NULL ? strsec->sh_size : 0;
@@ -7359,11 +7551,11 @@ get_32bit_dynamic_section (FILE * file)
   if (!edyn)
     return 0;
 
-/* SGI's ELF has more than one section in the DYNAMIC segment, and we
-   might not have the luxury of section headers.  Look for the DT_NULL
-   terminator to determine the number of entries.  */
+  /* SGI's ELF has more than one section in the DYNAMIC segment, and we
+     might not have the luxury of section headers.  Look for the DT_NULL
+     terminator to determine the number of entries.  */
   for (ext = edyn, dynamic_nent = 0;
-       (char *) ext < (char *) edyn + dynamic_size;
+       (char *) ext < (char *) edyn + dynamic_size - sizeof (* entry);
        ext++)
     {
       dynamic_nent++;
@@ -7375,7 +7567,8 @@ get_32bit_dynamic_section (FILE * file)
                                                   sizeof (* entry));
   if (dynamic_section == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory allocating space for %lu dynamic entries\n"),
+	     (unsigned long) dynamic_nent);
       free (edyn);
       return 0;
     }
@@ -7526,6 +7723,7 @@ process_dynamic_section (FILE * file)
 	    section.sh_entsize = sizeof (Elf32_External_Sym);
 	  else
 	    section.sh_entsize = sizeof (Elf64_External_Sym);
+	  section.sh_name = string_table_length;
 
 	  num_dynamic_syms = section.sh_size / section.sh_entsize;
 	  if (num_dynamic_syms < 1)
@@ -7597,7 +7795,11 @@ process_dynamic_section (FILE * file)
 	    {
 	      /* Note: these braces are necessary to avoid a syntax
 		 error from the SunOS4 C compiler.  */
-	      assert (sizeof (Elf_External_Syminfo) == entry->d_un.d_val);
+	      /* PR binutils/17531: A corrupt file can trigger this test.
+		 So do not use an assert, instead generate an error message.  */
+	      if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)
+		error (_("Bad value (%d) for SYMINENT entry\n"),
+		       (int) entry->d_un.d_val);
 	    }
 	  else if (entry->d_tag == DT_SYMINSZ)
 	    syminsz = entry->d_un.d_val;
@@ -7622,7 +7824,8 @@ process_dynamic_section (FILE * file)
 	  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
 	  if (dynamic_syminfo == NULL)
 	    {
-	      error (_("Out of memory\n"));
+	      error (_("Out of memory allocating %lu byte for dynamic symbol info\n"),
+		     (unsigned long) syminsz);
 	      return 0;
 	    }
 
@@ -7640,8 +7843,8 @@ process_dynamic_section (FILE * file)
     }
 
   if (do_dynamic && dynamic_addr)
-    printf (_("\nDynamic section at offset 0x%lx contains %u entries:\n"),
-	    dynamic_addr, dynamic_nent);
+    printf (_("\nDynamic section at offset 0x%lx contains %lu entries:\n"),
+	    dynamic_addr, (unsigned long) dynamic_nent);
   if (do_dynamic)
     printf (_("  Tag        Type                         Name/Value\n"));
 
@@ -7993,9 +8196,14 @@ process_dynamic_section (FILE * file)
 	      time_t time = entry->d_un.d_val;
 
 	      tmp = gmtime (&time);
-	      printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
-		      tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
-		      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+	      /* PR 17533 file: 041-1244816-0.004.  */
+	      if (tmp == NULL)
+		printf (_("<corrupt time val: %lx"),
+			(unsigned long) time);
+	      else
+		printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
+			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
+			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
 
 	    }
 	  break;
@@ -8102,17 +8310,15 @@ process_version_sections (FILE * file)
 
 	    found = 1;
 
-	    printf
-	      (_("\nVersion definition section '%s' contains %u entries:\n"),
-	       SECTION_NAME (section), section->sh_info);
+            printf (_("\nVersion definition section '%s' contains %u entries:\n"),
+                    printable_section_name (section),
+                    section->sh_info);
 
 	    printf (_("  Addr: 0x"));
 	    printf_vma (section->sh_addr);
 	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
 		    (unsigned long) section->sh_offset, section->sh_link,
-		    section->sh_link < elf_header.e_shnum
-		    ? SECTION_NAME (section_headers + section->sh_link)
-		    : "<corrupt>");
+                    printable_section_name_from_index (section->sh_link));
 
 	    edefs = (Elf_External_Verdef *)
                 get_data (NULL, file, section->sh_offset, 1,section->sh_size,
@@ -8222,15 +8428,13 @@ process_version_sections (FILE * file)
 	    found = 1;
 
 	    printf (_("\nVersion needs section '%s' contains %u entries:\n"),
-		    SECTION_NAME (section), section->sh_info);
+                    printable_section_name (section), section->sh_info);
 
 	    printf (_(" Addr: 0x"));
 	    printf_vma (section->sh_addr);
 	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
 		    (unsigned long) section->sh_offset, section->sh_link,
-		    section->sh_link < elf_header.e_shnum
-		    ? SECTION_NAME (section_headers + section->sh_link)
-		    : "<corrupt>");
+                    printable_section_name_from_index (section->sh_link));
 
 	    eneed = (Elf_External_Verneed *) get_data (NULL, file,
                                                        section->sh_offset, 1,
@@ -8327,8 +8531,8 @@ process_version_sections (FILE * file)
 	case SHT_GNU_versym:
 	  {
 	    Elf_Internal_Shdr * link_section;
-	    int total;
-	    int cnt;
+	    size_t total;
+	    unsigned int cnt;
 	    unsigned char * edata;
 	    unsigned short * data;
 	    char * strtab;
@@ -8362,14 +8566,14 @@ process_version_sections (FILE * file)
 		break;
 	      }
 
-	    printf (_("\nVersion symbols section '%s' contains %d entries:\n"),
-		    SECTION_NAME (section), total);
+	    printf (_("\nVersion symbols section '%s' contains %lu entries:\n"),
+		    printable_section_name (section), (unsigned long) total);
 
 	    printf (_(" Addr: "));
 	    printf_vma (section->sh_addr);
 	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
 		    (unsigned long) section->sh_offset, section->sh_link,
-		    SECTION_NAME (link_section));
+		    printable_section_name (link_section));
 
 	    off = offset_from_vma (file,
 				   version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
@@ -8833,30 +9039,41 @@ get_symbol_index_type (unsigned int type
 }
 
 static bfd_vma *
-get_dynamic_data (FILE * file, unsigned int number, unsigned int ent_size)
+get_dynamic_data (FILE * file, size_t number, unsigned int ent_size)
 {
   unsigned char * e_data;
   bfd_vma * i_data;
 
-  e_data = (unsigned char *) cmalloc (number, ent_size);
+  /* Be kind to memory chekers (eg valgrind, address sanitizer) by not
+     attempting to allocate memory when the read is bound to fail.  */
+  if (ent_size * number > current_file_size)
+    {
+      error (_("Invalid number of dynamic entries: %lu\n"),
+	     (unsigned long) number);
+      return NULL;
+    }
 
+  e_data = (unsigned char *) cmalloc (number, ent_size);
   if (e_data == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory reading %lu dynamic entries\n"),
+	     (unsigned long) number);
       return NULL;
     }
 
   if (fread (e_data, ent_size, number, file) != number)
     {
-      error (_("Unable to read in dynamic data\n"));
+      error (_("Unable to read in %lu bytes of dynamic data\n"),
+	     (unsigned long) (number * ent_size));
+      free (e_data);
       return NULL;
     }
 
   i_data = (bfd_vma *) cmalloc (number, sizeof (*i_data));
-
   if (i_data == NULL)
     {
-      error (_("Out of memory\n"));
+      error (_("Out of memory allocating space for %lu dynamic entries\n"),
+	     (unsigned long) number);
       free (e_data);
       return NULL;
     }
@@ -8907,14 +9124,15 @@ static int
 process_symbol_table (FILE * file)
 {
   Elf_Internal_Shdr * section;
-  bfd_vma nbuckets = 0;
-  bfd_vma nchains = 0;
+  bfd_size_type nbuckets = 0;
+  bfd_size_type nchains = 0;
   bfd_vma * buckets = NULL;
   bfd_vma * chains = NULL;
   bfd_vma ngnubuckets = 0;
   bfd_vma * gnubuckets = NULL;
   bfd_vma * gnuchains = NULL;
   bfd_vma gnusymidx = 0;
+  bfd_size_type ngnuchains = 0;
 
   if (!do_syms && !do_dyn_syms && !do_histogram)
     return 1;
@@ -8927,7 +9145,7 @@ process_symbol_table (FILE * file)
     {
       unsigned char nb[8];
       unsigned char nc[8];
-      int hash_ent_size = 4;
+      unsigned int hash_ent_size = 4;
 
       if ((elf_header.e_machine == EM_ALPHA
 	   || elf_header.e_machine == EM_S390
@@ -9076,6 +9294,7 @@ process_symbol_table (FILE * file)
 	}
 
       gnuchains = get_dynamic_data (file, maxchain, 4);
+      ngnuchains = maxchain;
 
     no_gnu_hash:
       if (gnuchains == NULL)
@@ -9091,7 +9310,8 @@ process_symbol_table (FILE * file)
   if ((dynamic_info[DT_HASH] || dynamic_info_DT_GNU_HASH)
       && do_syms
       && do_using_dynamic
-      && dynamic_strings != NULL)
+      && dynamic_strings != NULL
+      && dynamic_symbols != NULL)
     {
       unsigned long hn;
 
@@ -9161,8 +9382,8 @@ process_symbol_table (FILE * file)
 	    continue;
 
 	  printf (_("\nSymbol table '%s' contains %lu entries:\n"),
-		  SECTION_NAME (section),
+                  printable_section_name (section),
 		  (unsigned long) (section->sh_size / section->sh_entsize));
 	  if (is_32bit_elf)
 	    printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
 	  else
@@ -9398,14 +9619,15 @@ process_symbol_table (FILE * file)
 
       printf (_("\nHistogram for bucket list length (total of %lu buckets):\n"),
 	      (unsigned long) nbuckets);
-      printf (_(" Length  Number     %% of total  Coverage\n"));
 
       lengths = (unsigned long *) calloc (nbuckets, sizeof (*lengths));
       if (lengths == NULL)
 	{
-	  error (_("Out of memory\n"));
+	  error (_("Out of memory allocating space for histogram buckets\n"));
 	  return 0;
 	}
+
+      printf (_(" Length  Number     %% of total  Coverage\n"));
       for (hn = 0; hn < nbuckets; ++hn)
 	{
 	  for (si = buckets[hn]; si > 0 && si < nchains; si = chains[si])
@@ -9413,6 +9635,15 @@ process_symbol_table (FILE * file)
 	      ++nsyms;
 	      if (maxlength < ++lengths[hn])
 		++maxlength;
+
+	      /* PR binutils/17531: A corrupt binary could contain broken
+		 histogram data.  Do not go into an infinite loop trying
+		 to process it.  */
+	      if (chains[si] == si)
+		{
+		  error (_("histogram chain links to itself\n"));
+		  break;
+		}
 	    }
 	}
 
@@ -9459,15 +9690,16 @@ process_symbol_table (FILE * file)
       unsigned long nzero_counts = 0;
       unsigned long nsyms = 0;
 
+      printf (_("\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"),
+	      (unsigned long) ngnubuckets);
+
       lengths = (unsigned long *) calloc (ngnubuckets, sizeof (*lengths));
       if (lengths == NULL)
 	{
-	  error (_("Out of memory\n"));
+	  error (_("Out of memory allocating space for gnu histogram buckets\n"));
 	  return 0;
 	}
 
-      printf (_("\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"),
-	      (unsigned long) ngnubuckets);
       printf (_(" Length  Number     %% of total  Coverage\n"));
 
       for (hn = 0; hn < ngnubuckets; ++hn)
@@ -9476,7 +9708,9 @@ process_symbol_table (FILE * file)
 	    bfd_vma off, length = 1;
 
 	    for (off = gnubuckets[hn] - gnusymidx;
-		 (gnuchains[off] & 1) == 0; ++off)
+		 /* PR 17531 file: 010-77222-0.004.  */
+		 off < ngnuchains && (gnuchains[off] & 1) == 0;
+		 ++off)
 	      ++length;
 	    lengths[hn] = length;
 	    if (length > maxlength)
@@ -9541,7 +9775,9 @@ process_syminfo (FILE * file ATTRIBUTE_U
       unsigned short int flags = dynamic_syminfo[i].si_flags;
 
       printf ("%4d: ", i);
-      if (VALID_DYNAMIC_NAME (dynamic_symbols[i].st_name))
+      if (i >= num_dynamic_syms)
+	printf (_("<corrupt index>"));
+      else if (VALID_DYNAMIC_NAME (dynamic_symbols[i].st_name))
 	print_symbol (30, GET_DYNAMIC_NAME (dynamic_symbols[i].st_name));
       else
 	printf (_("<corrupt: %19ld>"), dynamic_symbols[i].st_name);
@@ -9626,7 +9862,7 @@ target_specific_reloc_handling (Elf_Inte
 	    break;
 	  default:
 	    if (saved_sym != NULL)
-	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc"));
+	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
 	    break;
 	  }
 	break;
@@ -10110,7 +10346,7 @@ apply_relocations (void * file,
 	  else
 	    {
 	      warn (_("unable to apply unsupported reloc type %d to section %s\n"),
-		    reloc_type, SECTION_NAME (section));
+		    reloc_type, printable_section_name (section));
 	      continue;
 	    }
 
@@ -10119,7 +10355,7 @@ apply_relocations (void * file,
 	    {
 	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
 		    (unsigned long) rp->r_offset,
-		    SECTION_NAME (section));
+		    printable_section_name (section));
 	      continue;
 	    }
 
@@ -10144,7 +10380,7 @@ apply_relocations (void * file,
 	      warn (_("skipping unexpected symbol type %s in %ld'th relocation in section %s\n"),
 		    get_symbol_type (ELF_ST_TYPE (sym->st_info)),
 		    (long int)(rp - relocs),
-		    SECTION_NAME (relsec));
+		    printable_section_name (relsec));
 	      continue;
 	    }
 
@@ -10187,10 +10423,9 @@ apply_relocations (void * file,
 static int
 disassemble_section (Elf_Internal_Shdr * section, FILE * file)
 {
-  printf (_("\nAssembly dump of section %s\n"),
-	  SECTION_NAME (section));
+  printf (_("\nAssembly dump of section %s\n"), printable_section_name (section));
 
-  /* XXX -- to be done --- XXX */
+  /* FIXME: XXX -- to be done --- XXX */
 
   return 1;
 }
@@ -10209,7 +10444,7 @@ get_section_contents (Elf_Internal_Shdr
   if (num_bytes == 0 || section->sh_type == SHT_NOBITS)
     {
       printf (_("\nSection '%s' has no data to dump.\n"),
-	      SECTION_NAME (section));
+	      printable_section_name (section));
       return NULL;
     }
 
@@ -10226,14 +10461,13 @@ dump_section_as_strings (Elf_Internal_Sh
   char * data;
   char * end;
   char * start;
-  char * name = SECTION_NAME (section);
   bfd_boolean some_strings_shown;
 
   start = get_section_contents (section, file);
   if (start == NULL)
     return;
 
-  printf (_("\nString dump of section '%s':\n"), name);
+  printf (_("\nString dump of section '%s':\n"), printable_section_name (section));
 
   /* If the section being dumped has relocations against it the user might
      be expecting these relocations to have been applied.  Check for this
@@ -10268,12 +10502,24 @@ dump_section_as_strings (Elf_Internal_Sh
 
       if (data < end)
 	{
+          size_t maxlen = end - data;
+
 #ifndef __MSVCRT__
-	  printf ("  [%6tx]  %s\n", data - start, data);
+	  printf ("  [%6tx]  ", data - start);
 #else
-	  printf ("  [%6Ix]  %s\n", (size_t) (data - start), data);
+	  printf ("  [%6Ix]  ", (size_t) (data - start));
 #endif
-	  data += strlen (data);
+          if (maxlen > 0)
+            {
+              print_symbol ((int) maxlen, data);
+              putchar ('\n');
+              data += strnlen (data, maxlen);
+            }
+          else
+            {
+              printf (_("<corrupt>\n"));
+              data = end;
+            }
 	  some_strings_shown = TRUE;
 	}
     }
@@ -10304,7 +10549,7 @@ dump_section_as_bytes (Elf_Internal_Shdr
   if (start == NULL)
     return;
 
-  printf (_("\nHex dump of section '%s':\n"), SECTION_NAME (section));
+  printf (_("\nHex dump of section '%s':\n"), printable_section_name (section));
 
   if (relocate)
     {
@@ -10525,6 +10770,7 @@ static int
 display_debug_section (Elf_Internal_Shdr * section, FILE * file)
 {
   char * name = SECTION_NAME (section);
+  const char * print_name = printable_section_name (section);
   bfd_size_type length;
   int result = 1;
   int i;
@@ -10532,7 +10778,7 @@ display_debug_section (Elf_Internal_Shdr
   length = section->sh_size;
   if (length == 0)
     {
-      printf (_("\nSection '%s' has no debugging data.\n"), name);
+      printf (_("\nSection '%s' has no debugging data.\n"), print_name);
       return 0;
     }
   if (section->sh_type == SHT_NOBITS)
@@ -10541,7 +10787,8 @@ display_debug_section (Elf_Internal_Shdr
 	 which has the NOBITS type - the bits in the file will be random.
 	 This can happen when a file containing a .eh_frame section is
 	 stripped with the --only-keep-debug command line option.  */
-      printf (_("section '%s' has the NOBITS type - its contents are unreliable.\n"), name);
+      printf (_("section '%s' has the NOBITS type - its contents are unreliable.\n"),
+	      print_name);
       return 0;
     }
 
@@ -10577,7 +10824,7 @@ display_debug_section (Elf_Internal_Shdr
 
   if (i == max)
     {
-      printf (_("Unrecognized debug section: %s\n"), name);
+      printf (_("Unrecognized debug section: %s\n"), print_name);
       result = 0;
     }
 
@@ -11716,7 +11964,10 @@ process_mips_specific (FILE * file)
     /* No information available.  */
     return 0;
 
-  for (entry = dynamic_section; entry->d_tag != DT_NULL; ++entry)
+  for (entry = dynamic_section;
+       /* PR 17531 file: 012-50589-0.004.  */
+       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;
+       ++entry)
     switch (entry->d_tag)
       {
       case DT_MIPS_LIBLIST:
@@ -11857,8 +12108,13 @@ process_mips_specific (FILE * file)
       int cnt;
 
       /* Find the section header so that we get the size.  */
-      while (sect->sh_type != SHT_MIPS_OPTIONS)
-	++sect;
+      sect = find_section_by_type (SHT_MIPS_OPTIONS);
+      /* PR 17533 file: 012-277276-0.004.  */ 
+      if (sect == NULL)
+	{
+	  error (_("No MIPS_OPTIONS header found\n"));
+	  return 0;
+	}
 
       eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,
                                                 sect->sh_size, _("options"));
@@ -11868,7 +12124,7 @@ process_mips_specific (FILE * file)
               cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));
 	  if (iopt == NULL)
 	    {
-	      error (_("Out of memory\n"));
+	      error (_("Out of memory allocatinf space for MIPS options\n"));
 	      return 0;
 	    }
 
@@ -11893,7 +12149,7 @@ process_mips_specific (FILE * file)
 	    }
 
 	  printf (_("\nSection '%s' contains %d entries:\n"),
-		  SECTION_NAME (sect), cnt);
+		  printable_section_name (sect), cnt);
 
 	  option = iopt;
 
@@ -12060,7 +12316,7 @@ process_mips_specific (FILE * file)
       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
       if (iconf == NULL)
 	{
-	  error (_("Out of memory\n"));
+	  error (_("Out of memory allocating space for dynamic conflicts\n"));
 	  return 0;
 	}
 
@@ -12101,15 +12357,22 @@ process_mips_specific (FILE * file) (XXX 83)
 
       for (cnt = 0; cnt < conflictsno; ++cnt)
 	{
-	  Elf_Internal_Sym * psym = & dynamic_symbols[iconf[cnt]];
-
 	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);
-	  print_vma (psym->st_value, FULL_HEX);
-	  putchar (' ');
-	  if (VALID_DYNAMIC_NAME (psym->st_name))
-	    print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
+          if (iconf[cnt] >= num_dynamic_syms)
+            printf (_("<corrupt symbol index>"));
 	  else
-	    printf ("<corrupt: %14ld>", psym->st_name);
+            {
+              Elf_Internal_Sym * psym;
+ 
+              psym = & dynamic_symbols[iconf[cnt]];
+              print_vma (psym->st_value, FULL_HEX);
+              putchar (' ');
+              if (VALID_DYNAMIC_NAME (psym->st_name))
+                print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
+              else
+                printf (_("<corrupt: %14ld>"), psym->st_name);
+            }
+
 	  putchar ('\n');
 	}
 
@@ -12126,8 +12389,17 @@ process_mips_specific (FILE * file)
       ent = pltgot;
       addr_size = (is_32bit_elf ? 4 : 8);
       local_end = pltgot + local_gotno * addr_size;
-      global_end = local_end + (symtabno - gotsym) * addr_size;
 
+      /* PR binutils/17533 file: 012-111227-0.004  */
+      if (symtabno < gotsym)
+	{
+	  error (_("The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"),
+		 (long) gotsym, (long) symtabno);
+	  return 0;
+	}
+ 
+      global_end = local_end + (symtabno - gotsym) * addr_size;
+      assert (global_end >= local_end);
       offset = offset_from_vma (file, pltgot, global_end - pltgot);
       data = (unsigned char *) get_data (NULL, file, offset,
                                          global_end - pltgot, 1, _("GOT"));
@@ -12178,21 +12450,32 @@ process_mips_specific (FILE * file)
 		  addr_size * 2, "Initial",
 		  addr_size * 2, "Sym.Val.", "Type", "Ndx", "Name");
 	  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;
+
 	  for (i = gotsym; i < symtabno; i++)
 	    {
-	      Elf_Internal_Sym * psym;
-
-	      psym = dynamic_symbols + i;
 	      entry = print_mips_got_entry (data, pltgot, entry);
 	      printf (" ");
-	      print_vma (psym->st_value, LONG_HEX);
-	      printf (" %-7s %3s ",
-		      get_symbol_type (ELF_ST_TYPE (psym->st_info)),
-		      get_symbol_index_type (psym->st_shndx));
-	      if (VALID_DYNAMIC_NAME (psym->st_name))
-		print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
+              
+              if (dynamic_symbols == NULL)
+                printf (_("<no dynamic symbols>"));
+              else if (i < num_dynamic_syms)
+                {
+                  Elf_Internal_Sym * psym = dynamic_symbols + i;
+ 
+                  print_vma (psym->st_value, LONG_HEX);
+                  printf (" %-7s %3s ",
+                          get_symbol_type (ELF_ST_TYPE (psym->st_info)),
+                          get_symbol_index_type (psym->st_shndx));
+ 
+                  if (VALID_DYNAMIC_NAME (psym->st_name))
+                    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
+                  else
+                    printf (_("<corrupt: %14ld>"), psym->st_name);
+                }
 	      else
-		printf ("<corrupt: %14ld>", psym->st_name);
+                printf (_("<symbol index %lu exceeds number of dynamic symbols>"),
+                        (unsigned long) i);
+
 	      printf ("\n");
 	    }
 	  printf ("\n");
@@ -12251,19 +12534,26 @@ process_mips_specific (FILE * file)
       sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
       for (i = 0; i < count; i++)
 	{
-	  Elf_Internal_Sym * psym;
+          unsigned long idx = get_reloc_symindex (rels[i].r_info);
 
-	  psym = dynamic_symbols + get_reloc_symindex (rels[i].r_info);
 	  entry = print_mips_pltgot_entry (data, mips_pltgot, entry);
 	  printf (" ");
-	  print_vma (psym->st_value, LONG_HEX);
-	  printf (" %-7s %3s ",
-		  get_symbol_type (ELF_ST_TYPE (psym->st_info)),
-		  get_symbol_index_type (psym->st_shndx));
-	  if (VALID_DYNAMIC_NAME (psym->st_name))
-	    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
+                  
+          if (idx >= num_dynamic_syms)
+            printf (_("<corrupt symbol index: %lu>"), idx);
 	  else
-	    printf ("<corrupt: %14ld>", psym->st_name);
+            {
+              Elf_Internal_Sym * psym = dynamic_symbols + idx;
+      
+              print_vma (psym->st_value, LONG_HEX);
+              printf (" %-7s %3s ",
+                      get_symbol_type (ELF_ST_TYPE (psym->st_info)),
+                      get_symbol_index_type (psym->st_shndx));
+              if (VALID_DYNAMIC_NAME (psym->st_name))
+                print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
+              else
+                printf (_("<corrupt: %14ld>"), psym->st_name);
+            }
 	  printf ("\n");
 	}
       printf ("\n");
@@ -12321,7 +12611,7 @@ process_gnu_liblist (FILE * file)
 	  strtab_size = string_sec->sh_size;
 
 	  printf (_("\nLibrary list section '%s' contains %lu entries:\n"),
-		  SECTION_NAME (section),
+		  printable_section_name (section),
 		  (unsigned long) (section->sh_size / sizeof (Elf32_External_Lib)));
 
 	  puts (_("     Library              Time Stamp          Checksum   Version Flags"));
@@ -12886,7 +13183,7 @@ process_corefile_note_segment (FILE * fi
 
 	  if (temp == NULL)
 	    {
-	      error (_("Out of memory\n"));
+	      error (_("Out of memory allocating space for inote name\n"));
 	      res = 0;
 	      break;
 	    }
@@ -13087,9 +13384,9 @@ get_file_header (FILE * file)
       /* There may be some extensions in the first section header.  Don't
 	 bomb if we can't read it.  */
       if (is_32bit_elf)
-	get_32bit_section_headers (file, 1);
+	get_32bit_section_headers (file, TRUE);
       else
-	get_64bit_section_headers (file, 1);
+	get_64bit_section_headers (file, TRUE);
     }
 
   return 1;
@@ -13517,6 +13814,8 @@ process_file (char * file_name)
       return 1;
     }
 
+  current_file_size = (bfd_size_type) statbuf.st_size;
+
   if (memcmp (armag, ARMAG, SARMAG) == 0)
     ret = process_archive (file_name, file, FALSE);
   else if (memcmp (armag, ARMAGT, SARMAG) == 0)
@@ -13534,6 +13833,7 @@ process_file (char * file_name)
 
   fclose (file);
 
+  current_file_size = 0;
   return ret;
 }
 
--- a/binutils/stabs.c
+++ b/binutils/stabs.c
@@ -837,8 +837,6 @@ parse_stab_string (void *dhandle, struct
 
     case 'G':
       {
-	char leading;
-	long c;
 	asymbol **ps;
 
 	/* A global symbol.  The value must be extracted from the
@@ -847,19 +845,27 @@ parse_stab_string (void *dhandle, struct
 				 (debug_type **) NULL);
 	if (dtype == DEBUG_TYPE_NULL)
 	  return FALSE;
-	leading = bfd_get_symbol_leading_char (info->abfd);
-	for (c = info->symcount, ps = info->syms; c > 0; --c, ++ps)
+	if (name != NULL)
 	  {
-	    const char *n;
+	    char leading;
+	    long c;
 
-	    n = bfd_asymbol_name (*ps);
-	    if (leading != '\0' && *n == leading)
-	      ++n;
-	    if (*n == *name && strcmp (n, name) == 0)
-	      break;
+	    leading = bfd_get_symbol_leading_char (info->abfd);
+	    for (c = info->symcount, ps = info->syms; c > 0; --c, ++ps)
+	      {
+		const char *n;
+
+		n = bfd_asymbol_name (*ps);
+		if (leading != '\0' && *n == leading)
+		  ++n;
+		if (*n == *name && strcmp (n, name) == 0)
+		  break;
+	      }
+
+	    if (c > 0)
+	      value = bfd_asymbol_value (*ps);
 	  }
-	if (c > 0)
-	  value = bfd_asymbol_value (*ps);
+
 	if (! stab_record_variable (dhandle, info, name, dtype, DEBUG_GLOBAL,
 				    value))
 	  return FALSE;
--- a/gas/config/obj-coff.c
+++ b/gas/config/obj-coff.c
@@ -389,6 +389,7 @@ coff_obj_symbol_new_hook (symbolS *symbo
 
   memset (s, 0, sz);
   coffsymbol (symbol_get_bfdsym (symbolP))->native = (combined_entry_type *) s;
+  coffsymbol (symbol_get_bfdsym (symbolP))->native->is_sym = TRUE;
 
   S_SET_DATA_TYPE (symbolP, T_NULL);
   S_SET_STORAGE_CLASS (symbolP, 0);
--- a/bfd/pei-x86_64.c
+++ b/bfd/pei-x86_64.c
@@ -439,6 +439,12 @@ pex64_bfd_print_pdata (bfd *abfd, void *
     return TRUE;
 
   stop = pei_section_data (abfd, section)->virt_size;
+  /* PR 17512: file: 005-181405-0.004.  */
+  if (stop == 0 || section->size == 0)
+    {
+      fprintf (file, _("No unwind data in .pdata section\n"));
+      return TRUE;
+    }
   if ((stop % onaline) != 0)
     fprintf (file,
 	     _("warning: .pdata section size (%ld) is not a multiple of %d\n"),
