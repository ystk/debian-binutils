#! /bin/sh /usr/share/dpatch/dpatch-run
Description: Fix for CVE-2014-8503 CVE-2014-8502 CVE-2014-8737
Author: Luciano Bello <luciano@debian.org>
Origin: backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=32a9d621c3c480aa093a089a36e36c35f68a4010
        backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=690725fa0d98ae52c991f4b3ea58b6b47b4fbc80
        backport: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=a5c71af8d3c7c535f27614947f72883233658706
Applied-Upstream: commit:32a9d621c3c480aa093a089a36e36c35f68a4010
                  commit:690725fa0d98ae52c991f4b3ea58b6b47b4fbc80
                  commit:a5c71af8d3c7c535f27614947f72883233658706
---
@DPATCH@
--- a/binutils/dwarf.c
+++ b/binutils/dwarf.c
@@ -191,14 +191,40 @@ size_of_encoded_value (int encoding)
 }
 
 static dwarf_vma
-get_encoded_value (unsigned char *data, int encoding)
+get_encoded_value (unsigned char **pdata,
+                   int encoding,
+                   struct dwarf_section *section,
+                   unsigned char * end)
 {
-  int size = size_of_encoded_value (encoding);
+  unsigned char * data = * pdata;
+  unsigned int size = size_of_encoded_value (encoding);
+  dwarf_vma val;
+
+  if (data + size >= end)
+    {
+      warn (_("Encoded value extends past end of section\n"));
+      * pdata = end;
+      return 0;
+    }
+
+  /* PR 17512: file: 002-829853-0.004.  */
+  if (size > 8)
+    {
+      warn (_("Encoded size of %d is too large to read\n"), size);
+      * pdata = end;
+      return 0;
+    }
 
   if (encoding & DW_EH_PE_signed)
-    return byte_get_signed (data, size);
+    val = byte_get_signed (data, size);
   else
-    return byte_get (data, size);
+    val = byte_get (data, size);
+
+  if ((encoding & 0x70) == DW_EH_PE_pcrel)
+    val += section->address + (data - section->start);
+
+  * pdata = data + size;
+  return val;
 }
 
 /* Print a dwarf_vma value (typically an address, offset or length) in
@@ -240,7 +259,7 @@ reset_state_machine (int is_stmt)
    Returns the number of bytes read.  */
 
 static int
-process_extended_line_op (unsigned char *data, int is_stmt)
+process_extended_line_op (unsigned char *data, int is_stmt, unsigned char * end)
 {
   unsigned char op_code;
   unsigned int bytes_read;
@@ -251,9 +270,9 @@ process_extended_line_op (unsigned char
   len = read_leb128 (data, & bytes_read, 0);
   data += bytes_read;
 
-  if (len == 0)
+  if (len == 0 || data == end )
     {
-      warn (_("badly formed extended line op encountered!\n"));
+      warn (_("Badly formed extended line op encountered!\n"));
       return bytes_read;
     }
 
@@ -270,6 +289,10 @@ process_extended_line_op (unsigned char
       break;
 
     case DW_LNE_set_address:
+      /* PR 17512: file: 002-100480-0.004.  */
+      if (len - bytes_read - 1 > 8)
+       warn (_("Length (%d) of DW_LNE_set_address op is too long\n"),
+             len - bytes_read - 1);
       adr = byte_get (data, len - bytes_read - 1);
       printf (_("set Address to 0x%lx\n"), adr);
       state_machine_regs.address = adr;
@@ -700,10 +723,15 @@ get_FORM_name (unsigned long form)
 }
 
 static unsigned char *
-display_block (unsigned char *data, unsigned long length)
+display_block (unsigned char *data, dwarf_vma length, const unsigned char * const end)
 {
-  printf (_(" %lu byte block: "), length);
+  dwarf_vma maxlen;
+
+  printf (_(" %lu byte block: "), (unsigned long)length);
+
+  maxlen = (dwarf_vma) (end - data);
+  length = length > maxlen ? maxlen : length;
 
   while (length --)
     printf ("%lx ", (unsigned long) byte_get (data++, 1));

@@ -1089,8 +1117,7 @@ decode_location_expression (unsigned cha
 	  printf ("DW_OP_implicit_value");
 	  uvalue = read_leb128 (data, &bytes_read, 0);
 	  data += bytes_read;
-	  display_block (data, uvalue);
-	  data += uvalue;
+	  data = display_block (data, uvalue, end);
 	  break;
 
 	  /* GNU extensions.  */
@@ -1103,14 +1130,12 @@ decode_location_expression (unsigned cha
 	  break;
 	case DW_OP_GNU_encoded_addr:
 	  {
-	    int encoding;
+	    int encoding=0;
 	    dwarf_vma addr;
 	
-	    encoding = *data++;
-	    addr = get_encoded_value (data, encoding);
-	    if ((encoding & 0x70) == DW_EH_PE_pcrel)
-	      addr += section->address + (data - section->start);
-	    data += size_of_encoded_value (encoding);
+            if (data < end)
+              encoding = *data++;
+            addr = get_encoded_value (&data, encoding, section, end);
 
 	    printf ("DW_OP_GNU_encoded_addr: fmt:%02x addr:", encoding);
 	    print_dwarf_vma (addr, pointer_size);
@@ -1250,6 +1278,7 @@ static unsigned char *
 read_and_display_attr_value (unsigned long attribute,
 			     unsigned long form,
 			     unsigned char * data,
+                             unsigned char * end,
 			     unsigned long cu_offset,
 			     unsigned long pointer_size,
 			     unsigned long offset_size,
@@ -1263,6 +1292,12 @@ read_and_display_attr_value (unsigned lo
   unsigned char * orig_data = data;
   unsigned int bytes_read;
 
+  if (data > end || (data == end && form != DW_FORM_flag_present))
+     {
+       warn (_("Corrupt attribute\n"));
+       return data;
+     }
+
   switch (form)
     {
     default:
@@ -1333,7 +1368,7 @@ read_and_display_attr_value (unsigned lo
       data += bytes_read;
       if (!do_loc)
 	printf (" %s", get_FORM_name (form));
-      return read_and_display_attr_value (attribute, form, data,
+      return read_and_display_attr_value (attribute, form, data, end,
 					  cu_offset, pointer_size,
 					  offset_size, dwarf_version,
 					  debug_info_p, do_loc,
@@ -1401,37 +1436,58 @@ read_and_display_attr_value (unsigned lo
     case DW_FORM_exprloc:
       uvalue = read_leb128 (data, & bytes_read, 0);
       block_start = data + bytes_read;
+      /* PR 17512: file: 008-103549-0.001:0.1.  */
+      if (block_start + uvalue > end)
+	{
+	  warn (_("Corrupt attribute block length: %lx\n"), (long) uvalue);
+	  uvalue = end - block_start;
+	}
       if (do_loc)
 	data = block_start + uvalue;
       else
-	data = display_block (block_start, uvalue);
+	data = display_block (block_start, uvalue, end);
       break;
 
     case DW_FORM_block1:
       uvalue = byte_get (data, 1);
       block_start = data + 1;
+      if (block_start + uvalue > end)
+	{
+	  warn (_("Corrupt attribute block length: %lx\n"), (long) uvalue);
+	  uvalue = end - block_start;
+	}
       if (do_loc)
 	data = block_start + uvalue;
       else
-	data = display_block (block_start, uvalue);
+	data = display_block (block_start, uvalue, end);
       break;
 
     case DW_FORM_block2:
       uvalue = byte_get (data, 2);
       block_start = data + 2;
+      if (block_start + uvalue > end)
+	{
+	  warn (_("Corrupt attribute block length: %lx\n"), (long) uvalue);
+	  uvalue = end - block_start;
+	}
       if (do_loc)
 	data = block_start + uvalue;
       else
-	data = display_block (block_start, uvalue);
+	data = display_block (block_start, uvalue, end);
       break;
 
     case DW_FORM_block4:
       uvalue = byte_get (data, 4);
       block_start = data + 4;
+      if (block_start + uvalue > end)
+	{
+	  warn (_("Corrupt attribute block length: %lx\n"), (long) uvalue);
+	  uvalue = end - block_start;
+	}
       if (do_loc)
 	data = block_start + uvalue;
       else
-	data = display_block (block_start, uvalue);
+	data = display_block (block_start, uvalue, end);
       break;
 
     case DW_FORM_strp:
@@ -1987,6 +2043,7 @@ static unsigned char *
 read_and_display_attr (unsigned long attribute,
 		       unsigned long form,
 		       unsigned char * data,
+                       unsigned char * end,
 		       unsigned long cu_offset,
 		       unsigned long pointer_size,
 		       unsigned long offset_size,
@@ -1997,7 +2054,7 @@ read_and_display_attr (unsigned long att
 {
   if (!do_loc)
     printf ("   %-18s:", get_AT_name (attribute));
-  data = read_and_display_attr_value (attribute, form, data, cu_offset,
+  data = read_and_display_attr_value (attribute, form, data, end, cu_offset,
 				      pointer_size, offset_size,
 				      dwarf_version, debug_info_p,
 				      do_loc, section);
@@ -2067,7 +2124,7 @@ process_debug_info (struct dwarf_section
 
       if (num_units == 0)
 	{
-	  error (_("No comp units in %s section ?"), section->name);
+	  error (_("No comp units in %s section ?\n"), section->name);
 	  return 0;
 	}
 
@@ -2076,7 +2133,7 @@ process_debug_info (struct dwarf_section
                                                   sizeof (* debug_information));
       if (debug_information == NULL)
 	{
-	  error (_("Not enough memory for a debug info array of %u entries"),
+	  error (_("Not enough memory for a debug info array of %u entries\n"),
 		 num_units);
 	  return 0;
 	}
@@ -2153,6 +2210,15 @@ process_debug_info (struct dwarf_section

       compunit.cu_pointer_size = byte_get (hdrptr, 1);
       hdrptr += 1;
+
+      /* PR 17512: file: 001-108546-0.001:0.1.  */
+      if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)
+        {
+          warn (_("Invalid pointer size (%d) in compunit header, using %d instead\n"),
+                compunit.cu_pointer_size, offset_size);
+          compunit.cu_pointer_size = offset_size;
+        }
+
       if ((do_loc || do_debug_loc || do_debug_ranges)
 	  && num_debug_info_entries == 0)
 	{
@@ -2356,7 +2421,7 @@ process_debug_info (struct dwarf_section
 
 	      tags = read_and_display_attr (attr->attribute,
 					    attr->form,
-					    tags, cu_offset,
+					    tags, end, cu_offset,
 					    compunit.cu_pointer_size,
 					    offset_size,
 					    compunit.cu_version,
@@ -2536,6 +2607,9 @@ display_debug_lines_raw (struct dwarf_se
 
 	      data += strlen ((char *) data) + 1;
 	    }
+            /* PR 17512: file: 002-132094-0.004.  */
+            if (data >= end - 1)
+               break;
 	}
 
       /* Skip the NUL at the end of the table.  */
@@ -2555,7 +2629,7 @@ display_debug_lines_raw (struct dwarf_se
 	  printf (_("\n The File Name Table:\n"));
 	  printf (_("  Entry\tDir\tTime\tSize\tName\n"));
 
-	  while (*data != 0)
+	  while (data < end && *data != 0)
 	    {
 	      unsigned char *name;
 	      unsigned int bytes_read;
@@ -2629,7 +2703,7 @@ display_debug_lines_raw (struct dwarf_se
 	  else switch (op_code)
 	    {
 	    case DW_LNS_extended_op:
-	      data += process_extended_line_op (data, info.li_default_is_stmt);
+	      data += process_extended_line_op (data, info.li_default_is_stmt, end);
 	      break;
 
 	    case DW_LNS_copy:
@@ -2875,6 +2949,14 @@ display_debug_lines_decoded (struct dwar
       /* Find the end of this CU's Line Number Information Block.  */
       end_of_sequence = data + info.li_length + initial_length_size;
 
+      /* PR 17512: file:002-117414-0.004.  */ 
+      if (end_of_sequence > end)
+        {
+          warn (_("Line length %lu extends beyond end of section\n"), info.li_length);
+          end_of_sequence = end;
+          return 0;
+        }
+
       reset_state_machine (info.li_default_is_stmt);
 
       /* Save a pointer to the contents of the Opcodes table.  */
@@ -3366,8 +3448,12 @@ display_debug_pubnames (struct dwarf_sec
 	  if (offset != 0)
 	    {
 	      data += offset_size;
+              if (data >= end)
+                 break;
 	      printf ("    %-6lx\t%s\n", offset, data);
 	      data += strlen ((char *) data) + 1;
+              if (data >= end)
+                 break;
 	    }
 	}
       while (offset != 0);
@@ -4217,6 +4303,14 @@ display_debug_aranges (struct dwarf_sect
 
       address_size = arange.ar_pointer_size + arange.ar_segment_size;
 
+      /* PR 17512: file: 001-108546-0.001:0.1.  */
+      if (address_size == 0 || address_size > 8)
+        {
+          error (_("Invalid address size in %s section!\n"),
+                 section->name);
+          break;
+        }
+
       /* The DWARF spec does not require that the address size be a power
 	 of two, but we do.  This will have to change if we ever encounter
 	 an uneven architecture.  */
@@ -4370,6 +4457,14 @@ display_debug_ranges (struct dwarf_secti
       next = section_begin + offset;
       base_address = debug_info_p->base_address;
 
+      /* PR 17512: file: 001-101485-0.001:0.1.  */
+      if (pointer_size < 2 || pointer_size > 8)
+       {
+         warn (_("Corrupt pointer size (%d) in debug entry at offset %8.8lx\n"),
+               pointer_size, offset);
+         continue;
+       }
+
       if (i > 0)
 	{
 	  if (start < next)
@@ -4483,6 +4578,14 @@ frame_need_space (Frame_Chunk *fc, unsig
   fc->col_type = (short int *) xcrealloc (fc->col_type, fc->ncols,
                                           sizeof (short int));
   fc->col_offset = (int *) xcrealloc (fc->col_offset, fc->ncols, sizeof (int));
+  /* PR 17512: file:002-10025-0.005.  */ 
+  if (fc->col_type == NULL || fc->col_offset == NULL)
+    {
+      error (_("Out of memory allocating %u columns in dwarf frame arrays\n"),
+	     fc->ncols);
+      fc->ncols = 0;
+      return -1;
+    }
 
   while (prev < fc->ncols)
     {
@@ -4702,6 +4805,12 @@ display_debug_frames (struct dwarf_secti
 	{
 	  printf ("\n%08lx ZERO terminator\n\n",
 		    (unsigned long)(saved_start - section_start));
+          /* Skip any zero terminators that directly follow.
+             A corrupt section size could have loaded a whole
+             slew of zero filled memory bytes.  eg
+             PR 17512: file: 070-19381-0.004.  */
+          while (start < end && * start == 0)
+            ++ start;
 	  continue;
 	}
 
@@ -4719,7 +4828,7 @@ display_debug_frames (struct dwarf_secti
 	}
 
       block_end = saved_start + length + initial_length_size;
-      if (block_end > end)
+      if (block_end > end || block_end < start)
 	{
 	  warn ("Invalid length %#08lx in FDE at %#08lx\n",
 		length, (unsigned long)(saved_start - section_start));
@@ -4745,7 +4854,17 @@ display_debug_frames (struct dwarf_secti
 	  version = *start++;
 
 	  fc->augmentation = (char *) start;
-	  start = (unsigned char *) strchr ((char *) start, '\0') + 1;
+          /* PR 17512: file: 001-228113-0.004.
+             Skip past augmentation name, but avoid running off the end of the data.  */
+          while (start < end)
+            if (* start ++ == '\0')
+              break;
+          if (start == end)
+            {
+              warn (_("No terminator for augmentation name\n"));
+              return 0;
+            }
+
 
 	  if (strcmp (fc->augmentation, "eh") == 0)
 	    start += eh_addr_size;
@@ -4896,10 +5015,8 @@ display_debug_frames (struct dwarf_secti
 	  if (fc->fde_encoding)
 	    encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);
 
-	  fc->pc_begin = get_encoded_value (start, fc->fde_encoding);
-	  if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
-	    fc->pc_begin += section->address + (start - section_start);
-	  start += encoded_ptr_size;
+          fc->pc_begin = get_encoded_value (&start, fc->fde_encoding, section, end);
+	  /*ERR in original patch: start += encoded_ptr_size; */
 	  fc->pc_range = byte_get (start, encoded_ptr_size);
 	  start += encoded_ptr_size;

@@ -4941,8 +5060,8 @@ display_debug_frames (struct dwarf_secti
 
 	  while (start < block_end)
 	    {
-	      unsigned op, opa;
-	      unsigned long reg, tmp;
+              unsigned int reg, op, opa;
+              unsigned long temp;

 	      op = *start++;
 	      opa = op & 0x3f;
@@ -5014,14 +5133,27 @@ display_debug_frames (struct dwarf_secti
 		  LEB ();
 		  break;
 		case DW_CFA_def_cfa_expression:
-		  tmp = LEB ();
-		  start += tmp;
+		  temp = LEB ();
+                  if (start + temp < start)
+                    {
+                      warn (_("Corrupt CFA_def expression value: %lu\n"), temp);
+                      start = block_end;
+                    }
+                  else
+                    start += temp;
 		  break;
 		case DW_CFA_expression:
 		case DW_CFA_val_expression:
 		  reg = LEB ();
-		  tmp = LEB ();
-		  start += tmp;
+		  temp = LEB ();
+                  if (start + temp < start)
+                    {
+                      /* PR 17512: file:306-192417-0.005.  */
+                      warn (_("Corrupt CFA expression value: %lu\n"), temp);
+                      start = block_end;
+                    }
+                  else
+                    start += temp;
 		  if (frame_need_space (fc, reg) >= 0)
 		    fc->col_type[reg] = DW_CFA_undefined;
 		  break;
@@ -5114,10 +5246,7 @@ display_debug_frames (struct dwarf_secti
 	      break;
 
 	    case DW_CFA_set_loc:
-	      vma = get_encoded_value (start, fc->fde_encoding);
-	      if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
-		vma += section->address + (start - section_start);
-	      start += encoded_ptr_size;
+              vma = get_encoded_value (&start, fc->fde_encoding, section, block_end);
 	      if (do_debug_frames_interp)
 		frame_display_row (fc, &need_col_headers, &max_regs);
 	      else
@@ -5312,6 +5443,12 @@ display_debug_frames (struct dwarf_secti
 
 	    case DW_CFA_def_cfa_expression:
 	      ul = LEB ();
+              if (start >= block_end)
+                {
+                  printf ("  DW_CFA_def_cfa_expression: <corrupt>\n");
+                  warn (_("Corrupt length field in DW_CFA_def_cfa_expression\n"));
+                  break;
+                }
 	      if (! do_debug_frames_interp)
 		{
 		  printf ("  DW_CFA_def_cfa_expression (");
@@ -5328,6 +5465,15 @@ display_debug_frames (struct dwarf_secti
 	      ul = LEB ();
 	      if (reg >= (unsigned int) fc->ncols)
 		reg_prefix = bad_reg;
+
+              /* PR 17512: file: 069-133014-0.006.  */
+              if (start >= block_end)
+                {
+                  printf ("  DW_CFA_expression: <corrupt>\n");
+                  warn (_("Corrupt length field in DW_CFA_expression\n"));
+                  break;
+                }
+
 	      if (! do_debug_frames_interp || *reg_prefix != '\0')
 		{
 		  printf ("  DW_CFA_expression: %s%s (",
@@ -5346,6 +5492,14 @@ display_debug_frames (struct dwarf_secti
 	      ul = LEB ();
 	      if (reg >= (unsigned int) fc->ncols)
 		reg_prefix = bad_reg;
+
+              if (start >= block_end)
+                {
+                  printf ("  DW_CFA_val_expression: <corrupt>\n");
+                  warn (_("Corrupt length field in DW_CFA_val_expression\n"));
+                  break;
+                }
+
 	      if (! do_debug_frames_interp || *reg_prefix != '\0')
 		{
 		  printf ("  DW_CFA_val_expression: %s%s (",
@@ -5450,7 +5604,7 @@ display_debug_frames (struct dwarf_secti
 	      if (op >= DW_CFA_lo_user && op <= DW_CFA_hi_user)
 		printf (_("  DW_CFA_??? (User defined call frame op: %#x)\n"), op);
 	      else
-		warn (_("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"), op);
+		warn (_("Unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"), op);
 	      start = block_end;
 	    }
 	}
